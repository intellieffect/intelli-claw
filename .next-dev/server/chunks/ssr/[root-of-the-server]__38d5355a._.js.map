{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/BIGNO-FC2T/Projects/intelli-claw/src/lib/gateway/protocol.ts"],"sourcesContent":["import { v4 as uuidv4 } from \"uuid\";\n\n// --- Frame Types (aligned with OpenClaw Gateway Protocol v3) ---\n\nexport interface ReqFrame {\n  type: \"req\";\n  id: string;\n  method: string;\n  params?: unknown;\n}\n\nexport interface ErrorShape {\n  code: string;\n  message: string;\n  details?: unknown;\n  retryable?: boolean;\n  retryAfterMs?: number;\n}\n\nexport interface ResFrame {\n  type: \"res\";\n  id: string;\n  ok: boolean;\n  payload?: unknown;\n  error?: ErrorShape;\n}\n\nexport interface StateVersion {\n  presence: number;\n  health: number;\n}\n\nexport interface EventFrame {\n  type: \"event\";\n  event: string;\n  payload?: unknown;\n  seq?: number;\n  stateVersion?: StateVersion;\n}\n\nexport type Frame = ReqFrame | ResFrame | EventFrame;\n\n// --- Connect Handshake Types ---\n\nexport type ClientId =\n  | \"cli\" | \"test\" | \"webchat\" | \"webchat-ui\" | \"openclaw-control-ui\"\n  | \"gateway-client\" | \"openclaw-macos\" | \"openclaw-ios\" | \"openclaw-android\"\n  | \"node-host\" | \"fingerprint\" | \"openclaw-probe\";\n\nexport type ClientMode = \"cli\" | \"node\" | \"ui\" | \"test\" | \"webchat\" | \"backend\" | \"probe\";\n\nexport interface ConnectClient {\n  id: ClientId;\n  displayName?: string;\n  version: string;\n  platform: string;\n  deviceFamily?: string;\n  modelIdentifier?: string;\n  mode: ClientMode;\n  instanceId?: string;\n}\n\nexport interface DeviceIdentity {\n  id: string;\n  publicKey: string;\n  signature: string;\n  signedAt: number;\n  nonce?: string;\n}\n\nexport interface ConnectParams {\n  minProtocol: number;\n  maxProtocol: number;\n  client: ConnectClient;\n  caps?: string[];\n  commands?: string[];\n  permissions?: Record<string, boolean>;\n  pathEnv?: string;\n  role?: string;\n  scopes?: string[];\n  device?: DeviceIdentity;\n  auth?: { token?: string; password?: string };\n  locale?: string;\n  userAgent?: string;\n}\n\nexport interface HelloOkPayload {\n  type: \"hello-ok\";\n  protocol: number;\n  server: {\n    version: string;\n    commit?: string;\n    host?: string;\n    connId: string;\n  };\n  features: {\n    methods: string[];\n    events: string[];\n  };\n  snapshot: {\n    presence: PresenceEntry[];\n    health: unknown;\n    stateVersion: StateVersion;\n    uptimeMs: number;\n    configPath?: string;\n    stateDir?: string;\n    sessionDefaults?: {\n      defaultAgentId: string;\n      mainKey: string;\n      mainSessionKey: string;\n      scope?: string;\n    };\n    authMode?: \"none\" | \"token\" | \"password\" | \"trusted-proxy\";\n  };\n  canvasHostUrl?: string;\n  auth?: {\n    deviceToken: string;\n    role: string;\n    scopes: string[];\n    issuedAtMs?: number;\n  };\n  policy: {\n    maxPayload: number;\n    maxBufferedBytes: number;\n    tickIntervalMs: number;\n  };\n}\n\nexport interface PresenceEntry {\n  host?: string;\n  ip?: string;\n  version?: string;\n  platform?: string;\n  deviceFamily?: string;\n  modelIdentifier?: string;\n  mode?: string;\n  lastInputSeconds?: number;\n  reason?: string;\n  tags?: string[];\n  text?: string;\n  ts: number;\n  deviceId?: string;\n  roles?: string[];\n  scopes?: string[];\n  instanceId?: string;\n}\n\n// --- Agent Event (real gateway format) ---\n\nexport interface GatewayAgentEvent {\n  runId: string;\n  seq: number;\n  stream: string;\n  ts: number;\n  data: Record<string, unknown>;\n}\n\n// --- Chat Types ---\n\nexport interface ChatSendParams {\n  sessionKey: string;\n  message: string;\n  thinking?: string;\n  deliver?: boolean;\n  attachments?: unknown[];\n  timeoutMs?: number;\n  idempotencyKey: string;\n}\n\nexport interface ChatAbortParams {\n  sessionKey: string;\n  runId?: string;\n}\n\nexport interface ChatHistoryParams {\n  sessionKey: string;\n  limit?: number;\n}\n\nexport interface ChatEvent {\n  runId: string;\n  sessionKey: string;\n  seq: number;\n  state: \"delta\" | \"final\" | \"aborted\" | \"error\";\n  message?: unknown;\n  errorMessage?: string;\n  usage?: unknown;\n  stopReason?: string;\n}\n\n// --- Legacy Agent Event Payloads (display-layer mapping) ---\n\nexport interface AgentTextDelta {\n  kind: \"text-delta\";\n  delta: string;\n  sessionKey?: string;\n}\n\nexport interface AgentToolCallStart {\n  kind: \"tool-call-start\";\n  callId: string;\n  name: string;\n  args?: string;\n  sessionKey?: string;\n}\n\nexport interface AgentToolCallEnd {\n  kind: \"tool-call-end\";\n  callId: string;\n  name: string;\n  result?: string;\n  sessionKey?: string;\n}\n\nexport interface AgentDone {\n  kind: \"done\";\n  sessionKey?: string;\n  text?: string;\n}\n\nexport interface AgentError {\n  kind: \"error\";\n  message: string;\n  sessionKey?: string;\n}\n\nexport type AgentEvent =\n  | AgentTextDelta\n  | AgentToolCallStart\n  | AgentToolCallEnd\n  | AgentDone\n  | AgentError;\n\n// --- Helpers ---\n\nexport function makeReq(method: string, params?: Record<string, unknown>): ReqFrame {\n  return { type: \"req\", id: uuidv4(), method, params };\n}\n\nexport function parseFrame(data: string): Frame | null {\n  try {\n    return JSON.parse(data) as Frame;\n  } catch {\n    return null;\n  }\n}\n\n// --- Data Types ---\n\nexport interface Agent {\n  id: string;\n  name?: string;\n  model?: string;\n  description?: string;\n  systemPrompt?: string;\n}\n\nexport interface Session {\n  key: string;\n  agentId?: string;\n  agentName?: string;\n  title?: string;\n  lastMessage?: string;\n  updatedAt?: string;\n  messageCount?: number;\n}\n\nexport interface ChatMessage {\n  role: \"user\" | \"assistant\" | \"system\" | \"tool\";\n  content: string;\n  timestamp?: string;\n  toolCalls?: ToolCall[];\n}\n\nexport interface ToolCall {\n  callId: string;\n  name: string;\n  args?: string;\n  result?: string;\n  status: \"running\" | \"done\" | \"error\";\n}\n"],"names":[],"mappings":";;;;;;AAAA;;AA2OO,SAAS,QAAQ,MAAc,EAAE,MAAgC;IACtE,OAAO;QAAE,MAAM;QAAO,IAAI,IAAA,mOAAM;QAAI;QAAQ;IAAO;AACrD;AAEO,SAAS,WAAW,IAAY;IACrC,IAAI;QACF,OAAO,KAAK,KAAK,CAAC;IACpB,EAAE,OAAM;QACN,OAAO;IACT;AACF","debugId":null}},
    {"offset": {"line": 43, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/BIGNO-FC2T/Projects/intelli-claw/src/lib/gateway/client.ts"],"sourcesContent":["import { makeReq, parseFrame, type Frame, type ResFrame, type EventFrame, type ErrorShape } from \"./protocol\";\n\nexport type ConnectionState = \"disconnected\" | \"connecting\" | \"authenticating\" | \"connected\";\ntype EventHandler = (event: EventFrame) => void;\ntype StateHandler = (state: ConnectionState) => void;\ntype PendingReq = {\n  resolve: (payload: unknown) => void;\n  reject: (error: Error) => void;\n  timer: ReturnType<typeof setTimeout>;\n};\n\nconst REQUEST_TIMEOUT = 30_000;\nconst RECONNECT_DELAYS = [1000, 2000, 4000, 8000, 16000];\n\nexport class GatewayClient {\n  private ws: WebSocket | null = null;\n  private url: string;\n  private token: string;\n  private state: ConnectionState = \"disconnected\";\n  private pending = new Map<string, PendingReq>();\n  private eventHandlers = new Set<EventHandler>();\n  private stateHandlers = new Set<StateHandler>();\n  private reconnectAttempt = 0;\n  private reconnectTimer: ReturnType<typeof setTimeout> | null = null;\n  private intentionalClose = false;\n  public mainSessionKey = \"\";\n\n  constructor(url: string, token: string) {\n    this.url = url;\n    this.token = token;\n  }\n\n  // --- Public API ---\n\n  connect(): void {\n    if (this.ws && this.state !== \"disconnected\") return;\n    this.intentionalClose = false;\n    this.setState(\"connecting\");\n\n    try {\n      this.ws = new WebSocket(this.url);\n      this.ws.onopen = () => this.handleOpen();\n      this.ws.onmessage = (e) => this.handleMessage(e);\n      this.ws.onclose = () => this.handleClose();\n      this.ws.onerror = () => {}; // onclose will fire\n    } catch {\n      this.handleClose();\n    }\n  }\n\n  disconnect(): void {\n    this.intentionalClose = true;\n    this.clearReconnect();\n    if (this.ws) {\n      this.ws.onclose = null;\n      this.ws.close();\n      this.ws = null;\n    }\n    this.rejectAll(\"Disconnected\");\n    this.setState(\"disconnected\");\n  }\n\n  async request<T = unknown>(method: string, params?: Record<string, unknown>): Promise<T> {\n    if (this.state !== \"connected\") {\n      throw new Error(`Not connected (state: ${this.state})`);\n    }\n    const frame = makeReq(method, params);\n    return new Promise<T>((resolve, reject) => {\n      const timer = setTimeout(() => {\n        this.pending.delete(frame.id);\n        reject(new Error(`Request timeout: ${method}`));\n      }, REQUEST_TIMEOUT);\n\n      this.pending.set(frame.id, {\n        resolve: resolve as (p: unknown) => void,\n        reject,\n        timer,\n      });\n      this.send(frame);\n    });\n  }\n\n  onEvent(handler: EventHandler): () => void {\n    this.eventHandlers.add(handler);\n    return () => this.eventHandlers.delete(handler);\n  }\n\n  onStateChange(handler: StateHandler): () => void {\n    this.stateHandlers.add(handler);\n    return () => this.stateHandlers.delete(handler);\n  }\n\n  getState(): ConnectionState {\n    return this.state;\n  }\n\n  // --- Private ---\n\n  private send(frame: Frame): void {\n    if (this.ws?.readyState === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify(frame));\n    }\n  }\n\n  private setState(state: ConnectionState): void {\n    if (this.state === state) return;\n    this.state = state;\n    this.stateHandlers.forEach((h) => h(state));\n  }\n\n  private handleOpen(): void {\n    this.setState(\"authenticating\");\n    // Wait for connect.challenge\n  }\n\n  private handleMessage(e: MessageEvent): void {\n    const frame = parseFrame(typeof e.data === \"string\" ? e.data : \"\");\n    if (!frame) return;\n\n    switch (frame.type) {\n      case \"event\":\n        this.handleEvent(frame as EventFrame);\n        break;\n      case \"res\":\n        this.handleResponse(frame as ResFrame);\n        break;\n    }\n  }\n\n  private handleEvent(frame: EventFrame): void {\n    if (frame.event === \"connect.challenge\") {\n      // Respond with Protocol v3 connect handshake\n      const authFrame = makeReq(\"connect\", {\n        minProtocol: 3,\n        maxProtocol: 3,\n        client: {\n          id: \"openclaw-control-ui\",\n          version: \"1.0.0\",\n          platform: \"web\",\n          mode: \"ui\",\n        },\n        role: \"operator\",\n        scopes: [\"operator.read\", \"operator.write\", \"operator.admin\"],\n        auth: { token: this.token },\n      });\n      this.send(authFrame);\n      return;\n    }\n\n    // Forward all other events\n    console.log(\"[AWF] Event:\", frame.event, JSON.stringify(frame.payload).slice(0, 200));\n    this.eventHandlers.forEach((h) => h(frame));\n  }\n\n  private handleResponse(frame: ResFrame): void {\n    // Check if this is the connect response (hello-ok)\n    const payload = frame.payload as Record<string, unknown> | undefined;\n    if (frame.ok && payload?.type === \"hello-ok\") {\n      const snapshot = payload.snapshot as Record<string, unknown> | undefined;\n      const sessionDefaults = snapshot?.sessionDefaults as Record<string, unknown> | undefined;\n      this.mainSessionKey = (sessionDefaults?.mainSessionKey as string) || \"\";\n      console.log(\"[AWF] hello-ok: mainSessionKey=\", this.mainSessionKey, \"auth=\", JSON.stringify(payload.auth));\n      this.reconnectAttempt = 0;\n      this.setState(\"connected\");\n    }\n\n    const pending = this.pending.get(frame.id);\n    if (!pending) return;\n\n    clearTimeout(pending.timer);\n    this.pending.delete(frame.id);\n\n    if (frame.ok) {\n      pending.resolve(frame.payload);\n    } else {\n      const errObj = frame.error as ErrorShape | undefined;\n      const errMsg = errObj?.message || JSON.stringify(frame.error || \"Request failed\");\n      console.error(\"[AWF] Request failed:\", errMsg, frame.error);\n      pending.reject(new Error(errMsg));\n    }\n  }\n\n  private handleClose(): void {\n    this.ws = null;\n    this.rejectAll(\"Connection closed\");\n    this.setState(\"disconnected\");\n\n    if (!this.intentionalClose) {\n      this.scheduleReconnect();\n    }\n  }\n\n  private scheduleReconnect(): void {\n    this.clearReconnect();\n    const delay = RECONNECT_DELAYS[Math.min(this.reconnectAttempt, RECONNECT_DELAYS.length - 1)];\n    this.reconnectAttempt++;\n    this.reconnectTimer = setTimeout(() => this.connect(), delay);\n  }\n\n  private clearReconnect(): void {\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n  }\n\n  private rejectAll(reason: string): void {\n    this.pending.forEach((p) => {\n      clearTimeout(p.timer);\n      p.reject(new Error(reason));\n    });\n    this.pending.clear();\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 240, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/BIGNO-FC2T/Projects/intelli-claw/src/lib/gateway/hooks.tsx"],"sourcesContent":["\"use client\";\n\nimport {\n  createContext,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n  useCallback,\n  type ReactNode,\n} from \"react\";\nimport { GatewayClient, type ConnectionState } from \"./client\";\nimport type {\n  EventFrame,\n  AgentEvent,\n  Agent,\n  Session,\n  ChatMessage,\n  ToolCall,\n} from \"./protocol\";\n\n// --- Gateway Context ---\n\ninterface GatewayContextValue {\n  client: GatewayClient | null;\n  state: ConnectionState;\n}\n\nconst GatewayContext = createContext<GatewayContextValue>({\n  client: null,\n  state: \"disconnected\",\n});\n\nexport function GatewayProvider({ children }: { children: ReactNode }) {\n  const [client, setClient] = useState<GatewayClient | null>(null);\n  const [state, setState] = useState<ConnectionState>(\"disconnected\");\n\n  useEffect(() => {\n    const url = process.env.NEXT_PUBLIC_GATEWAY_URL || \"ws://127.0.0.1:18789\";\n    const token = process.env.NEXT_PUBLIC_GATEWAY_TOKEN || \"\";\n    console.log(\"[AWF] Connecting to gateway:\", url, \"token:\", token ? \"✓\" : \"✗\");\n\n    const c = new GatewayClient(url, token);\n    setClient(c);\n\n    const unsub = c.onStateChange((s) => {\n      console.log(\"[AWF] Gateway state:\", s);\n      setState(s);\n    });\n    c.connect();\n\n    return () => {\n      unsub();\n      c.disconnect();\n    };\n  }, []);\n\n  return (\n    <GatewayContext.Provider value={{ client, state }}>\n      {children}\n    </GatewayContext.Provider>\n  );\n}\n\nexport function useGateway() {\n  const ctx = useContext(GatewayContext);\n  return { ...ctx, mainSessionKey: ctx.client?.mainSessionKey || \"\" };\n}\n\n// --- useAgents ---\n\nexport function useAgents() {\n  const { client, state } = useGateway();\n  const [agents, setAgents] = useState<Agent[]>([]);\n  const [loading, setLoading] = useState(false);\n\n  const fetchAgents = useCallback(async () => {\n    if (!client || state !== \"connected\") return;\n    setLoading(true);\n    try {\n      const res = await client.request<{ defaultId: string; agents: Agent[] }>(\"agents.list\");\n      setAgents(res?.agents || []);\n    } catch {\n      // silently fail\n    } finally {\n      setLoading(false);\n    }\n  }, [client, state]);\n\n  useEffect(() => {\n    fetchAgents();\n  }, [fetchAgents]);\n\n  return { agents, loading, refresh: fetchAgents };\n}\n\n// --- useSessions ---\n\nexport function useSessions() {\n  const { client, state } = useGateway();\n  const [sessions, setSessions] = useState<Session[]>([]);\n  const [loading, setLoading] = useState(false);\n  const lastRefreshAtRef = useRef(0);\n\n  const fetchSessions = useCallback(async () => {\n    if (!client || state !== \"connected\") return;\n    setLoading(true);\n    try {\n      const res = await client.request<{ sessions: Array<Record<string, unknown>> }>(\"sessions.list\", { limit: 200 });\n      // Map gateway sessions to our Session type, preserving extra fields\n      const mapped = (res?.sessions || []).map((s) => ({\n        key: String(s.key || \"\"),\n        agentId: undefined,\n        agentName: undefined,\n        title: s.label ? String(s.label) : undefined,\n        lastMessage: undefined,\n        updatedAt: typeof s.updatedAt === \"number\" ? new Date(s.updatedAt).toISOString() : undefined,\n        messageCount: undefined,\n        // Extra fields for session-switcher\n        ...s,\n      })) as Session[];\n      setSessions(mapped);\n      lastRefreshAtRef.current = Date.now();\n    } catch {\n      // silently fail\n    } finally {\n      setLoading(false);\n    }\n  }, [client, state]);\n\n  const refreshThrottled = useCallback(() => {\n    const now = Date.now();\n    // Prevent burst refreshes when many agent events arrive\n    if (now - lastRefreshAtRef.current < 1200) return;\n    fetchSessions();\n  }, [fetchSessions]);\n\n  useEffect(() => {\n    fetchSessions();\n  }, [fetchSessions]);\n\n  // Realtime-ish updates: refresh sessions when agent turn finishes\n  useEffect(() => {\n    if (!client) return;\n    const unsub = client.onEvent((frame) => {\n      if (frame.event !== \"agent\") return;\n      const raw = frame.payload as Record<string, unknown>;\n      const stream = raw.stream as string | undefined;\n      const data = raw.data as Record<string, unknown> | undefined;\n\n      if (stream === \"lifecycle\" && (data?.phase === \"end\" || data?.phase === \"start\")) {\n        refreshThrottled();\n      }\n    });\n    return unsub;\n  }, [client, refreshThrottled]);\n\n  // Periodic safety refresh so header metadata does not go stale\n  useEffect(() => {\n    if (state !== \"connected\") return;\n    const id = setInterval(() => {\n      refreshThrottled();\n    }, 15000);\n    return () => clearInterval(id);\n  }, [state, refreshThrottled]);\n\n  return { sessions, loading, refresh: fetchSessions };\n}\n\n// --- Helpers ---\n\n/** Strip OpenClaw inbound metadata from user messages */\nfunction stripInboundMeta(text: string): string {\n  // Remove \"Conversation info (untrusted metadata):\\n```json\\n{...}\\n```\\n\" blocks\n  let cleaned = text.replace(/Conversation info \\(untrusted metadata\\):\\s*```json\\s*\\{[\\s\\S]*?\\}\\s*```\\s*/g, \"\");\n  // Remove \"[Thu 2026-02-19 21:46 GMT+9] \" style timestamps at start\n  cleaned = cleaned.replace(/^\\[[\\w\\s\\-:+]+\\]\\s*/g, \"\");\n  return cleaned.trim();\n}\n\n// --- useChat ---\n\nexport interface DisplayAttachment {\n  fileName: string;\n  mimeType: string;\n  /** data URL for local preview */\n  dataUrl?: string;\n}\n\nexport interface DisplayMessage {\n  id: string;\n  role: \"user\" | \"assistant\" | \"system\";\n  content: string;\n  timestamp: string;\n  toolCalls: ToolCall[];\n  streaming?: boolean;\n  /** Message is queued and not yet sent to the gateway */\n  queued?: boolean;\n  /** Attachments (images, files) */\n  attachments?: DisplayAttachment[];\n}\n\nexport function useChat(sessionKey?: string) {\n  const { client, state } = useGateway();\n  const [messages, setMessages] = useState<DisplayMessage[]>([]);\n  const [streaming, setStreaming] = useState(false);\n  const [loading, setLoading] = useState(false);\n  const streamBuf = useRef<{\n    id: string;\n    content: string;\n    toolCalls: Map<string, ToolCall>;\n  } | null>(null);\n  const sessionKeyRef = useRef(sessionKey);\n\n  // Queue storage key (must be before loadHistory which references it)\n  const queueStorageKey = sessionKey ? `awf:queue:${sessionKey}` : null;\n\n  // Reset state on session change\n  useEffect(() => {\n    if (sessionKeyRef.current !== sessionKey) {\n      sessionKeyRef.current = sessionKey;\n      setMessages([]);\n      setStreaming(false);\n      streamBuf.current = null;\n    }\n  }, [sessionKey]);\n\n  // Load history\n  const loadHistory = useCallback(async () => {\n    if (!client || state !== \"connected\") return;\n    setLoading(true);\n    try {\n      const res = await client.request<{ messages: ChatMessage[] }>(\n        \"chat.history\",\n        { sessionKey, limit: 100 }\n      );\n      const histMsgs: DisplayMessage[] = (res?.messages || [])\n        .filter((m) => m.role === \"user\" || m.role === \"assistant\" || m.role === \"system\")\n        .map((m, i) => {\n          // Extract text and images from content\n          let textContent = '';\n          const imgAttachments: DisplayAttachment[] = [];\n\n          if (typeof m.content === 'string') {\n            textContent = m.content;\n          } else if (Array.isArray(m.content)) {\n            const parts = m.content as Array<Record<string, unknown>>;\n            const hasToolUse = parts.some(p => p.type === 'tool_use');\n            for (const p of parts) {\n              if (p.type === 'text' && typeof p.text === 'string') {\n                // Skip short narration between tool calls (e.g. \"패널 루트에 ref:\")\n                if (hasToolUse && m.role === 'assistant') {\n                  const text = (p.text as string).trim();\n                  // Keep substantial text blocks (>100 chars or multi-line with content)\n                  if (text.length < 100 && !text.includes('\\n')) continue;\n                }\n                textContent += p.text;\n              } else if (p.type === 'image_url' || p.type === 'image') {\n                const url = typeof p.image_url === 'object' && p.image_url\n                  ? (p.image_url as Record<string, string>).url\n                  : typeof p.url === 'string' ? p.url\n                  : typeof p.source === 'object' && p.source\n                    ? `data:${(p.source as Record<string, string>).media_type};base64,${(p.source as Record<string, string>).data}`\n                    : undefined;\n                if (url) {\n                  imgAttachments.push({\n                    fileName: 'image',\n                    mimeType: 'image/png',\n                    dataUrl: url,\n                  });\n                }\n              }\n            }\n          } else {\n            textContent = String(m.content || '');\n          }\n\n          if (m.role === 'user') textContent = stripInboundMeta(textContent);\n\n          return {\n          id: `hist-${i}`,\n          role: (m.role === 'system' || (m.role === 'user' && /\\[System Message\\]|\\[sessionId:|^System:\\s*\\[/.test(textContent)))\n            ? 'system' as const\n            : m.role as \"user\" | \"assistant\",\n          content: textContent,\n          timestamp: m.timestamp || new Date().toISOString(),\n          toolCalls: m.toolCalls || [],\n          attachments: imgAttachments.length > 0 ? imgAttachments : undefined,\n        };});\n      // Restore queued messages from localStorage\n      const savedQueue = queueStorageKey ? localStorage.getItem(queueStorageKey) : null;\n      if (savedQueue) {\n        try {\n          const queue = JSON.parse(savedQueue) as { id: string; text: string }[];\n          queueRef.current = queue;\n          const queuedMsgs: DisplayMessage[] = queue.map((q) => ({\n            id: q.id,\n            role: \"user\" as const,\n            content: q.text,\n            timestamp: new Date().toISOString(),\n            toolCalls: [],\n            queued: true,\n          }));\n          setMessages([...histMsgs, ...queuedMsgs]);\n        } catch {\n          setMessages(histMsgs);\n        }\n      } else {\n        setMessages(histMsgs);\n      }\n    } catch {\n      // silently fail\n    } finally {\n      setLoading(false);\n    }\n  }, [client, state, sessionKey, queueStorageKey]);\n\n  useEffect(() => {\n    loadHistory();\n  }, [loadHistory]);\n\n  // Handle agent events\n  useEffect(() => {\n    if (!client) return;\n\n    // Deduplicate events by frame.seq to prevent double-rendering\n    let lastSeq = -1;\n\n    const unsub = client.onEvent((frame: EventFrame) => {\n      if (frame.event !== \"agent\") return;\n\n      // Deduplicate: gateway sometimes sends the same event twice\n      // Use frame-level seq (not payload.seq)\n      if (frame.seq != null) {\n        if (frame.seq <= lastSeq) return;\n        lastSeq = frame.seq;\n      }\n\n      const raw = frame.payload as Record<string, unknown>;\n\n      // Real Gateway payload: {runId, stream, data:{text,delta}, sessionKey}\n      const stream = raw.stream as string | undefined;\n      const data = raw.data as Record<string, unknown> | undefined;\n      const evSessionKey = raw.sessionKey as string | undefined;\n\n      // Filter events: only process events matching current session\n      if (evSessionKey && evSessionKey !== sessionKeyRef.current) return;\n      if (!evSessionKey && sessionKeyRef.current) return;\n\n      // Map real gateway events to our handler\n      if (stream === \"assistant\" && (typeof data?.delta === \"string\" || typeof data?.text === \"string\")) {\n        // Streamed delta or one-shot text\n        const chunk = (data?.delta as string | undefined) ?? (data?.text as string);\n          setStreaming(true);\n          if (!streamBuf.current) {\n            const id = `stream-${Date.now()}`;\n            streamBuf.current = { id, content: \"\", toolCalls: new Map() };\n          }\n          streamBuf.current.content += chunk;\n          const snap = streamBuf.current;\n          setMessages((prev) => {\n            const existing = prev.findIndex((m) => m.id === snap.id);\n            const msg: DisplayMessage = {\n              id: snap.id,\n              role: \"assistant\",\n              content: snap.content,\n              timestamp: new Date().toISOString(),\n              toolCalls: Array.from(snap.toolCalls.values()),\n              streaming: true,\n            };\n            if (existing >= 0) {\n              const next = [...prev];\n              next[existing] = msg;\n              return next;\n            }\n            return [...prev, msg];\n          });\n      } else if (stream === \"tool-start\" && data) {\n        // tool-call-start\n          const callId = (data.toolCallId || data.callId || \"\") as string;\n          const name = (data.name || data.tool || \"\") as string;\n          const args = data.args as string | undefined;\n          if (!streamBuf.current) {\n            const id = `stream-${Date.now()}`;\n            streamBuf.current = { id, content: \"\", toolCalls: new Map() };\n          }\n          streamBuf.current.toolCalls.set(callId, {\n            callId,\n            name,\n            args,\n            status: \"running\",\n          });\n          const snapTool = streamBuf.current;\n          setMessages((prev) => {\n            const existing = prev.findIndex((m) => m.id === snapTool.id);\n            const msg: DisplayMessage = {\n              id: snapTool.id,\n              role: \"assistant\",\n              content: snapTool.content,\n              timestamp: new Date().toISOString(),\n              toolCalls: Array.from(snapTool.toolCalls.values()),\n              streaming: true,\n            };\n            if (existing >= 0) {\n              const next = [...prev];\n              next[existing] = msg;\n              return next;\n            }\n            return [...prev, msg];\n          });\n      } else if (stream === \"tool-end\" && data) {\n        // tool-call-end\n          const callId = (data.toolCallId || data.callId || \"\") as string;\n          const result = data.result as string | undefined;\n          if (streamBuf.current) {\n            const tc = streamBuf.current.toolCalls.get(callId);\n            if (tc) {\n              tc.status = \"done\";\n              tc.result = result;\n            }\n            const snapEnd = streamBuf.current;\n            setMessages((prev) => {\n              const existing = prev.findIndex((m) => m.id === snapEnd.id);\n              if (existing >= 0) {\n                const next = [...prev];\n                next[existing] = {\n                  ...next[existing],\n                  toolCalls: Array.from(snapEnd.toolCalls.values()),\n                };\n                return next;\n              }\n              return prev;\n            });\n          }\n      } else if (stream === \"lifecycle\" && data?.phase === \"end\") {\n        // lifecycle end = done\n          setStreaming(false);\n          if (streamBuf.current) {\n            const finalId = streamBuf.current.id;\n            const finalContent = streamBuf.current.content;\n            const finalTools = Array.from(streamBuf.current.toolCalls.values());\n            setMessages((prev) =>\n              prev.map((m) =>\n                m.id === finalId\n                  ? { ...m, content: finalContent, toolCalls: finalTools, streaming: false }\n                  : m\n              )\n            );\n            streamBuf.current = null;\n          }\n      } else if (stream === \"done\" || stream === \"end\" || stream === \"finish\") {\n        // done\n          setStreaming(false);\n          if (streamBuf.current) {\n            const finalId = streamBuf.current.id;\n            const finalContent = (data?.text as string) || streamBuf.current.content;\n            const finalTools = Array.from(streamBuf.current.toolCalls.values());\n            setMessages((prev) =>\n              prev.map((m) =>\n                m.id === finalId\n                  ? { ...m, content: finalContent, toolCalls: finalTools, streaming: false }\n                  : m\n              )\n            );\n            streamBuf.current = null;\n          }\n      } else if (stream === \"error\") {\n        // error\n          setStreaming(false);\n          const errMsg = (data?.message || data?.error || \"Unknown error\") as string;\n          if (streamBuf.current) {\n            const errId = streamBuf.current.id;\n            setMessages((prev) =>\n              prev.map((m) =>\n                m.id === errId\n                  ? { ...m, content: m.content + `\\n\\n**Error:** ${errMsg}`, streaming: false }\n                  : m\n              )\n            );\n            streamBuf.current = null;\n          }\n      }\n    });\n\n    return unsub;\n  }, [client, sessionKey]);\n\n  // Message queue for messages sent while streaming — persist to localStorage\n  const queueRef = useRef<{ id: string; text: string }[]>(\n    (() => {\n      if (queueStorageKey && typeof window !== \"undefined\") {\n        try {\n          const saved = localStorage.getItem(queueStorageKey);\n          return saved ? JSON.parse(saved) : [];\n        } catch { return []; }\n      }\n      return [];\n    })()\n  );\n  const processingQueue = useRef(false);\n\n  const persistQueue = useCallback(() => {\n    if (!queueStorageKey) return;\n    if (queueRef.current.length > 0) {\n      localStorage.setItem(queueStorageKey, JSON.stringify(queueRef.current));\n    } else {\n      localStorage.removeItem(queueStorageKey);\n    }\n  }, [queueStorageKey]);\n\n  // Actually send a message to the gateway\n  const doSend = useCallback(\n    async (text: string, msgId: string) => {\n      if (!client || state !== \"connected\") return;\n      // Mark message as no longer queued\n      setMessages((prev) =>\n        prev.map((m) => (m.id === msgId ? { ...m, queued: false } : m))\n      );\n      setStreaming(true);\n      try {\n        await client.request(\"chat.send\", {\n          message: text,\n          idempotencyKey: `awf-${Date.now()}-${Math.random().toString(36).slice(2)}`,\n          sessionKey,\n        });\n      } catch (err) {\n        console.error(\"[AWF] chat.send error:\", String(err));\n        setStreaming(false);\n      }\n    },\n    [client, state, sessionKey]\n  );\n\n  // Process queue: send next message when streaming ends\n  const processQueue = useCallback(async () => {\n    if (processingQueue.current) return;\n    processingQueue.current = true;\n    while (queueRef.current.length > 0) {\n      const next = queueRef.current.shift()!;\n      persistQueue();\n      // Check if message was cancelled (removed from messages)\n      const stillExists = await new Promise<boolean>((resolve) => {\n        setMessages((prev) => {\n          resolve(prev.some((m) => m.id === next.id));\n          return prev;\n        });\n      });\n      if (stillExists) {\n        await doSend(next.text, next.id);\n        // Wait for streaming to finish before sending next\n        await new Promise<void>((resolve) => {\n          const check = () => {\n            // Poll streaming state - resolve when not streaming\n            setTimeout(() => {\n              setStreaming((s) => {\n                if (!s) resolve();\n                else check();\n                return s;\n              });\n            }, 200);\n          };\n          check();\n        });\n      }\n    }\n    processingQueue.current = false;\n  }, [doSend]);\n\n  // Send message (queues if currently streaming)\n  const sendMessage = useCallback(\n    (text: string) => {\n      if (!client || state !== \"connected\" || !text.trim()) return;\n\n      const msgId = `user-${Date.now()}-${Math.random().toString(36).slice(2)}`;\n      const userMsg: DisplayMessage = {\n        id: msgId,\n        role: \"user\",\n        content: text,\n        timestamp: new Date().toISOString(),\n        toolCalls: [],\n        queued: streaming,\n      };\n      setMessages((prev) => [...prev, userMsg]);\n\n      if (streaming) {\n        // Queue for later\n        queueRef.current.push({ id: msgId, text });\n        persistQueue();\n      } else {\n        // Send immediately\n        doSend(text, msgId);\n      }\n    },\n    [client, state, streaming, doSend]\n  );\n\n  // When streaming ends, process queue\n  useEffect(() => {\n    if (!streaming && queueRef.current.length > 0) {\n      processQueue();\n    }\n  }, [streaming, processQueue]);\n\n  // Cancel a queued message\n  const cancelQueued = useCallback((msgId: string) => {\n    queueRef.current = queueRef.current.filter((q) => q.id !== msgId);\n    persistQueue();\n    setMessages((prev) => prev.filter((m) => m.id !== msgId));\n  }, [persistQueue]);\n\n  // Abort\n  const abort = useCallback(async () => {\n    if (!client || state !== \"connected\") return;\n    try {\n      await client.request(\"chat.abort\", { sessionKey });\n    } catch {\n      // silently fail\n    }\n    setStreaming(false);\n  }, [client, state, sessionKey]);\n\n  // Add a user message to the display (for external callers like attachment sends)\n  const addUserMessage = useCallback((text: string, attachments?: DisplayAttachment[]) => {\n    const msgId = `user-${Date.now()}-${Math.random().toString(36).slice(2)}`;\n    const userMsg: DisplayMessage = {\n      id: msgId,\n      role: \"user\",\n      content: text,\n      timestamp: new Date().toISOString(),\n      toolCalls: [],\n      queued: streaming,\n      attachments,\n    };\n    setMessages((prev) => [...prev, userMsg]);\n    if (!streaming) {\n      setStreaming(true);\n    }\n  }, [streaming]);\n\n  return {\n    messages,\n    streaming,\n    loading,\n    sendMessage,\n    addUserMessage,\n    cancelQueued,\n    abort,\n    reload: loadHistory,\n  };\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 888, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/BIGNO-FC2T/Projects/intelli-claw/src/lib/utils.ts"],"sourcesContent":["import { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,GAAG,GAAG,MAAoB;IACxC,OAAO,IAAA,oOAAO,EAAC,IAAA,8LAAI,EAAC;AACtB","debugId":null}},
    {"offset": {"line": 903, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/BIGNO-FC2T/Projects/intelli-claw/src/components/ui/tooltip.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport { Tooltip as TooltipPrimitive } from \"radix-ui\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction TooltipProvider({\n  delayDuration = 0,\n  ...props\n}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {\n  return (\n    <TooltipPrimitive.Provider\n      data-slot=\"tooltip-provider\"\n      delayDuration={delayDuration}\n      {...props}\n    />\n  )\n}\n\nfunction Tooltip({\n  ...props\n}: React.ComponentProps<typeof TooltipPrimitive.Root>) {\n  return <TooltipPrimitive.Root data-slot=\"tooltip\" {...props} />\n}\n\nfunction TooltipTrigger({\n  ...props\n}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {\n  return <TooltipPrimitive.Trigger data-slot=\"tooltip-trigger\" {...props} />\n}\n\nfunction TooltipContent({\n  className,\n  sideOffset = 0,\n  children,\n  ...props\n}: React.ComponentProps<typeof TooltipPrimitive.Content>) {\n  return (\n    <TooltipPrimitive.Portal>\n      <TooltipPrimitive.Content\n        data-slot=\"tooltip-content\"\n        sideOffset={sideOffset}\n        className={cn(\n          \"bg-foreground text-background animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance\",\n          className\n        )}\n        {...props}\n      >\n        {children}\n        <TooltipPrimitive.Arrow className=\"bg-foreground fill-foreground z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]\" />\n      </TooltipPrimitive.Content>\n    </TooltipPrimitive.Portal>\n  )\n}\n\nexport { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }\n"],"names":[],"mappings":";;;;;;;;;;;AAGA;AAEA;AALA;;;;AAOA,SAAS,gBAAgB,EACvB,gBAAgB,CAAC,EACjB,GAAG,OACoD;IACvD,qBACE,gZAAC,kaAAgB,CAAC,QAAQ;QACxB,aAAU;QACV,eAAe;QACd,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,QAAQ,EACf,GAAG,OACgD;IACnD,qBAAO,gZAAC,kaAAgB,CAAC,IAAI;QAAC,aAAU;QAAW,GAAG,KAAK;;;;;;AAC7D;AAEA,SAAS,eAAe,EACtB,GAAG,OACmD;IACtD,qBAAO,gZAAC,kaAAgB,CAAC,OAAO;QAAC,aAAU;QAAmB,GAAG,KAAK;;;;;;AACxE;AAEA,SAAS,eAAe,EACtB,SAAS,EACT,aAAa,CAAC,EACd,QAAQ,EACR,GAAG,OACmD;IACtD,qBACE,gZAAC,kaAAgB,CAAC,MAAM;kBACtB,cAAA,gZAAC,kaAAgB,CAAC,OAAO;YACvB,aAAU;YACV,YAAY;YACZ,WAAW,IAAA,yHAAE,EACX,qaACA;YAED,GAAG,KAAK;;gBAER;8BACD,gZAAC,kaAAgB,CAAC,KAAK;oBAAC,WAAU;;;;;;;;;;;;;;;;;AAI1C","debugId":null}}]
}