{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/BIGNO-FC2T/Projects/intelli-claw/src/lib/gateway/protocol.ts"],"sourcesContent":["import { v4 as uuidv4 } from \"uuid\";\n\n// --- Frame Types (aligned with OpenClaw Gateway Protocol v3) ---\n\nexport interface ReqFrame {\n  type: \"req\";\n  id: string;\n  method: string;\n  params?: unknown;\n}\n\nexport interface ErrorShape {\n  code: string;\n  message: string;\n  details?: unknown;\n  retryable?: boolean;\n  retryAfterMs?: number;\n}\n\nexport interface ResFrame {\n  type: \"res\";\n  id: string;\n  ok: boolean;\n  payload?: unknown;\n  error?: ErrorShape;\n}\n\nexport interface StateVersion {\n  presence: number;\n  health: number;\n}\n\nexport interface EventFrame {\n  type: \"event\";\n  event: string;\n  payload?: unknown;\n  seq?: number;\n  stateVersion?: StateVersion;\n}\n\nexport type Frame = ReqFrame | ResFrame | EventFrame;\n\n// --- Connect Handshake Types ---\n\nexport type ClientId =\n  | \"cli\" | \"test\" | \"webchat\" | \"webchat-ui\" | \"openclaw-control-ui\"\n  | \"gateway-client\" | \"openclaw-macos\" | \"openclaw-ios\" | \"openclaw-android\"\n  | \"node-host\" | \"fingerprint\" | \"openclaw-probe\";\n\nexport type ClientMode = \"cli\" | \"node\" | \"ui\" | \"test\" | \"webchat\" | \"backend\" | \"probe\";\n\nexport interface ConnectClient {\n  id: ClientId;\n  displayName?: string;\n  version: string;\n  platform: string;\n  deviceFamily?: string;\n  modelIdentifier?: string;\n  mode: ClientMode;\n  instanceId?: string;\n}\n\nexport interface DeviceIdentity {\n  id: string;\n  publicKey: string;\n  signature: string;\n  signedAt: number;\n  nonce?: string;\n}\n\nexport interface ConnectParams {\n  minProtocol: number;\n  maxProtocol: number;\n  client: ConnectClient;\n  caps?: string[];\n  commands?: string[];\n  permissions?: Record<string, boolean>;\n  pathEnv?: string;\n  role?: string;\n  scopes?: string[];\n  device?: DeviceIdentity;\n  auth?: { token?: string; password?: string };\n  locale?: string;\n  userAgent?: string;\n}\n\nexport interface HelloOkPayload {\n  type: \"hello-ok\";\n  protocol: number;\n  server: {\n    version: string;\n    commit?: string;\n    host?: string;\n    connId: string;\n  };\n  features: {\n    methods: string[];\n    events: string[];\n  };\n  snapshot: {\n    presence: PresenceEntry[];\n    health: unknown;\n    stateVersion: StateVersion;\n    uptimeMs: number;\n    configPath?: string;\n    stateDir?: string;\n    sessionDefaults?: {\n      defaultAgentId: string;\n      mainKey: string;\n      mainSessionKey: string;\n      scope?: string;\n    };\n    authMode?: \"none\" | \"token\" | \"password\" | \"trusted-proxy\";\n  };\n  canvasHostUrl?: string;\n  auth?: {\n    deviceToken: string;\n    role: string;\n    scopes: string[];\n    issuedAtMs?: number;\n  };\n  policy: {\n    maxPayload: number;\n    maxBufferedBytes: number;\n    tickIntervalMs: number;\n  };\n}\n\nexport interface PresenceEntry {\n  host?: string;\n  ip?: string;\n  version?: string;\n  platform?: string;\n  deviceFamily?: string;\n  modelIdentifier?: string;\n  mode?: string;\n  lastInputSeconds?: number;\n  reason?: string;\n  tags?: string[];\n  text?: string;\n  ts: number;\n  deviceId?: string;\n  roles?: string[];\n  scopes?: string[];\n  instanceId?: string;\n}\n\n// --- Agent Event (real gateway format) ---\n\nexport interface GatewayAgentEvent {\n  runId: string;\n  seq: number;\n  stream: string;\n  ts: number;\n  data: Record<string, unknown>;\n}\n\n// --- Chat Types ---\n\nexport interface ChatSendParams {\n  sessionKey: string;\n  message: string;\n  thinking?: string;\n  deliver?: boolean;\n  attachments?: unknown[];\n  timeoutMs?: number;\n  idempotencyKey: string;\n}\n\nexport interface ChatAbortParams {\n  sessionKey: string;\n  runId?: string;\n}\n\nexport interface ChatHistoryParams {\n  sessionKey: string;\n  limit?: number;\n}\n\nexport interface ChatEvent {\n  runId: string;\n  sessionKey: string;\n  seq: number;\n  state: \"delta\" | \"final\" | \"aborted\" | \"error\";\n  message?: unknown;\n  errorMessage?: string;\n  usage?: unknown;\n  stopReason?: string;\n}\n\n// --- Legacy Agent Event Payloads (display-layer mapping) ---\n\nexport interface AgentTextDelta {\n  kind: \"text-delta\";\n  delta: string;\n  sessionKey?: string;\n}\n\nexport interface AgentToolCallStart {\n  kind: \"tool-call-start\";\n  callId: string;\n  name: string;\n  args?: string;\n  sessionKey?: string;\n}\n\nexport interface AgentToolCallEnd {\n  kind: \"tool-call-end\";\n  callId: string;\n  name: string;\n  result?: string;\n  sessionKey?: string;\n}\n\nexport interface AgentDone {\n  kind: \"done\";\n  sessionKey?: string;\n  text?: string;\n}\n\nexport interface AgentError {\n  kind: \"error\";\n  message: string;\n  sessionKey?: string;\n}\n\nexport type AgentEvent =\n  | AgentTextDelta\n  | AgentToolCallStart\n  | AgentToolCallEnd\n  | AgentDone\n  | AgentError;\n\n// --- Helpers ---\n\nexport function makeReq(method: string, params?: Record<string, unknown>): ReqFrame {\n  return { type: \"req\", id: uuidv4(), method, params };\n}\n\nexport function parseFrame(data: string): Frame | null {\n  try {\n    return JSON.parse(data) as Frame;\n  } catch {\n    return null;\n  }\n}\n\n// --- Data Types ---\n\nexport interface Agent {\n  id: string;\n  name?: string;\n  model?: string;\n  description?: string;\n  systemPrompt?: string;\n}\n\nexport interface Session {\n  key: string;\n  agentId?: string;\n  agentName?: string;\n  title?: string;\n  lastMessage?: string;\n  updatedAt?: string;\n  messageCount?: number;\n}\n\nexport interface ChatMessage {\n  role: \"user\" | \"assistant\" | \"system\" | \"tool\";\n  content: string;\n  timestamp?: string;\n  toolCalls?: ToolCall[];\n}\n\nexport interface ToolCall {\n  callId: string;\n  name: string;\n  args?: string;\n  result?: string;\n  status: \"running\" | \"done\" | \"error\";\n}\n"],"names":[],"mappings":";;;;;;AAAA;;AA2OO,SAAS,QAAQ,MAAc,EAAE,MAAgC;IACtE,OAAO;QAAE,MAAM;QAAO,IAAI,IAAA,8NAAM;QAAI;QAAQ;IAAO;AACrD;AAEO,SAAS,WAAW,IAAY;IACrC,IAAI;QACF,OAAO,KAAK,KAAK,CAAC;IACpB,EAAE,UAAM;QACN,OAAO;IACT;AACF","debugId":null}},
    {"offset": {"line": 34, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/BIGNO-FC2T/Projects/intelli-claw/src/lib/gateway/client.ts"],"sourcesContent":["import { makeReq, parseFrame, type Frame, type ResFrame, type EventFrame, type ErrorShape } from \"./protocol\";\n\nexport type ConnectionState = \"disconnected\" | \"connecting\" | \"authenticating\" | \"connected\";\ntype EventHandler = (event: EventFrame) => void;\ntype StateHandler = (state: ConnectionState) => void;\ntype PendingReq = {\n  resolve: (payload: unknown) => void;\n  reject: (error: Error) => void;\n  timer: ReturnType<typeof setTimeout>;\n};\n\nconst REQUEST_TIMEOUT = 30_000;\nconst RECONNECT_DELAYS = [1000, 2000, 4000, 8000, 16000];\n\nexport class GatewayClient {\n  private ws: WebSocket | null = null;\n  private url: string;\n  private token: string;\n  private state: ConnectionState = \"disconnected\";\n  private pending = new Map<string, PendingReq>();\n  private eventHandlers = new Set<EventHandler>();\n  private stateHandlers = new Set<StateHandler>();\n  private reconnectAttempt = 0;\n  private reconnectTimer: ReturnType<typeof setTimeout> | null = null;\n  private intentionalClose = false;\n  public mainSessionKey = \"\";\n\n  constructor(url: string, token: string) {\n    this.url = url;\n    this.token = token;\n  }\n\n  // --- Public API ---\n\n  connect(): void {\n    if (this.ws && this.state !== \"disconnected\") return;\n    this.intentionalClose = false;\n    this.setState(\"connecting\");\n\n    try {\n      this.ws = new WebSocket(this.url);\n      this.ws.onopen = () => this.handleOpen();\n      this.ws.onmessage = (e) => this.handleMessage(e);\n      this.ws.onclose = () => this.handleClose();\n      this.ws.onerror = () => {}; // onclose will fire\n    } catch {\n      this.handleClose();\n    }\n  }\n\n  disconnect(): void {\n    this.intentionalClose = true;\n    this.clearReconnect();\n    if (this.ws) {\n      this.ws.onclose = null;\n      this.ws.close();\n      this.ws = null;\n    }\n    this.rejectAll(\"Disconnected\");\n    this.setState(\"disconnected\");\n  }\n\n  async request<T = unknown>(method: string, params?: Record<string, unknown>): Promise<T> {\n    if (this.state !== \"connected\") {\n      throw new Error(`Not connected (state: ${this.state})`);\n    }\n    const frame = makeReq(method, params);\n    return new Promise<T>((resolve, reject) => {\n      const timer = setTimeout(() => {\n        this.pending.delete(frame.id);\n        reject(new Error(`Request timeout: ${method}`));\n      }, REQUEST_TIMEOUT);\n\n      this.pending.set(frame.id, {\n        resolve: resolve as (p: unknown) => void,\n        reject,\n        timer,\n      });\n      this.send(frame);\n    });\n  }\n\n  onEvent(handler: EventHandler): () => void {\n    this.eventHandlers.add(handler);\n    return () => this.eventHandlers.delete(handler);\n  }\n\n  onStateChange(handler: StateHandler): () => void {\n    this.stateHandlers.add(handler);\n    return () => this.stateHandlers.delete(handler);\n  }\n\n  getState(): ConnectionState {\n    return this.state;\n  }\n\n  // --- Private ---\n\n  private send(frame: Frame): void {\n    if (this.ws?.readyState === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify(frame));\n    }\n  }\n\n  private setState(state: ConnectionState): void {\n    if (this.state === state) return;\n    this.state = state;\n    this.stateHandlers.forEach((h) => h(state));\n  }\n\n  private handleOpen(): void {\n    this.setState(\"authenticating\");\n    // Wait for connect.challenge\n  }\n\n  private handleMessage(e: MessageEvent): void {\n    const frame = parseFrame(typeof e.data === \"string\" ? e.data : \"\");\n    if (!frame) return;\n\n    switch (frame.type) {\n      case \"event\":\n        this.handleEvent(frame as EventFrame);\n        break;\n      case \"res\":\n        this.handleResponse(frame as ResFrame);\n        break;\n    }\n  }\n\n  private handleEvent(frame: EventFrame): void {\n    if (frame.event === \"connect.challenge\") {\n      // Respond with Protocol v3 connect handshake\n      const authFrame = makeReq(\"connect\", {\n        minProtocol: 3,\n        maxProtocol: 3,\n        client: {\n          id: \"openclaw-control-ui\",\n          version: \"1.0.0\",\n          platform: \"web\",\n          mode: \"ui\",\n        },\n        role: \"operator\",\n        scopes: [\"operator.read\", \"operator.write\", \"operator.admin\"],\n        auth: { token: this.token },\n      });\n      this.send(authFrame);\n      return;\n    }\n\n    // Forward all other events\n    console.log(\"[AWF] Event:\", frame.event, JSON.stringify(frame.payload).slice(0, 200));\n    this.eventHandlers.forEach((h) => h(frame));\n  }\n\n  private handleResponse(frame: ResFrame): void {\n    // Check if this is the connect response (hello-ok)\n    const payload = frame.payload as Record<string, unknown> | undefined;\n    if (frame.ok && payload?.type === \"hello-ok\") {\n      const snapshot = payload.snapshot as Record<string, unknown> | undefined;\n      const sessionDefaults = snapshot?.sessionDefaults as Record<string, unknown> | undefined;\n      this.mainSessionKey = (sessionDefaults?.mainSessionKey as string) || \"\";\n      console.log(\"[AWF] hello-ok: mainSessionKey=\", this.mainSessionKey, \"auth=\", JSON.stringify(payload.auth));\n      this.reconnectAttempt = 0;\n      this.setState(\"connected\");\n    }\n\n    const pending = this.pending.get(frame.id);\n    if (!pending) return;\n\n    clearTimeout(pending.timer);\n    this.pending.delete(frame.id);\n\n    if (frame.ok) {\n      pending.resolve(frame.payload);\n    } else {\n      const errObj = frame.error as ErrorShape | undefined;\n      const errMsg = errObj?.message || JSON.stringify(frame.error || \"Request failed\");\n      console.error(\"[AWF] Request failed:\", errMsg, frame.error);\n      pending.reject(new Error(errMsg));\n    }\n  }\n\n  private handleClose(): void {\n    this.ws = null;\n    this.rejectAll(\"Connection closed\");\n    this.setState(\"disconnected\");\n\n    if (!this.intentionalClose) {\n      this.scheduleReconnect();\n    }\n  }\n\n  private scheduleReconnect(): void {\n    this.clearReconnect();\n    const delay = RECONNECT_DELAYS[Math.min(this.reconnectAttempt, RECONNECT_DELAYS.length - 1)];\n    this.reconnectAttempt++;\n    this.reconnectTimer = setTimeout(() => this.connect(), delay);\n  }\n\n  private clearReconnect(): void {\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n  }\n\n  private rejectAll(reason: string): void {\n    this.pending.forEach((p) => {\n      clearTimeout(p.timer);\n      p.reject(new Error(reason));\n    });\n    this.pending.clear();\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 237, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/BIGNO-FC2T/Projects/intelli-claw/src/lib/gateway/hooks.tsx"],"sourcesContent":["\"use client\";\n\nimport {\n  createContext,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n  useCallback,\n  type ReactNode,\n} from \"react\";\nimport { GatewayClient, type ConnectionState } from \"./client\";\nimport type {\n  EventFrame,\n  AgentEvent,\n  Agent,\n  Session,\n  ChatMessage,\n  ToolCall,\n} from \"./protocol\";\n\n// --- Gateway Context ---\n\ninterface GatewayContextValue {\n  client: GatewayClient | null;\n  state: ConnectionState;\n}\n\nconst GatewayContext = createContext<GatewayContextValue>({\n  client: null,\n  state: \"disconnected\",\n});\n\nexport function GatewayProvider({ children }: { children: ReactNode }) {\n  const [client, setClient] = useState<GatewayClient | null>(null);\n  const [state, setState] = useState<ConnectionState>(\"disconnected\");\n\n  useEffect(() => {\n    const url = process.env.NEXT_PUBLIC_GATEWAY_URL || \"ws://127.0.0.1:18789\";\n    const token = process.env.NEXT_PUBLIC_GATEWAY_TOKEN || \"\";\n    console.log(\"[AWF] Connecting to gateway:\", url, \"token:\", token ? \"✓\" : \"✗\");\n\n    const c = new GatewayClient(url, token);\n    setClient(c);\n\n    const unsub = c.onStateChange((s) => {\n      console.log(\"[AWF] Gateway state:\", s);\n      setState(s);\n    });\n    c.connect();\n\n    return () => {\n      unsub();\n      c.disconnect();\n    };\n  }, []);\n\n  return (\n    <GatewayContext.Provider value={{ client, state }}>\n      {children}\n    </GatewayContext.Provider>\n  );\n}\n\nexport function useGateway() {\n  const ctx = useContext(GatewayContext);\n  return { ...ctx, mainSessionKey: ctx.client?.mainSessionKey || \"\" };\n}\n\n// --- useAgents ---\n\nexport function useAgents() {\n  const { client, state } = useGateway();\n  const [agents, setAgents] = useState<Agent[]>([]);\n  const [loading, setLoading] = useState(false);\n\n  const fetchAgents = useCallback(async () => {\n    if (!client || state !== \"connected\") return;\n    setLoading(true);\n    try {\n      const res = await client.request<{ defaultId: string; agents: Agent[] }>(\"agents.list\");\n      setAgents(res?.agents || []);\n    } catch {\n      // silently fail\n    } finally {\n      setLoading(false);\n    }\n  }, [client, state]);\n\n  useEffect(() => {\n    fetchAgents();\n  }, [fetchAgents]);\n\n  return { agents, loading, refresh: fetchAgents };\n}\n\n// --- useSessions ---\n\nexport function useSessions() {\n  const { client, state } = useGateway();\n  const [sessions, setSessions] = useState<Session[]>([]);\n  const [loading, setLoading] = useState(false);\n  const lastRefreshAtRef = useRef(0);\n\n  const fetchSessions = useCallback(async () => {\n    if (!client || state !== \"connected\") return;\n    setLoading(true);\n    try {\n      const res = await client.request<{ sessions: Array<Record<string, unknown>> }>(\"sessions.list\", { limit: 200 });\n      // Map gateway sessions to our Session type, preserving extra fields\n      const mapped = (res?.sessions || []).map((s) => ({\n        key: String(s.key || \"\"),\n        agentId: undefined,\n        agentName: undefined,\n        title: s.label ? String(s.label) : undefined,\n        lastMessage: undefined,\n        updatedAt: typeof s.updatedAt === \"number\" ? new Date(s.updatedAt).toISOString() : undefined,\n        messageCount: undefined,\n        // Extra fields for session-switcher\n        ...s,\n      })) as Session[];\n      setSessions(mapped);\n      lastRefreshAtRef.current = Date.now();\n    } catch {\n      // silently fail\n    } finally {\n      setLoading(false);\n    }\n  }, [client, state]);\n\n  const refreshThrottled = useCallback(() => {\n    const now = Date.now();\n    // Prevent burst refreshes when many agent events arrive\n    if (now - lastRefreshAtRef.current < 1200) return;\n    fetchSessions();\n  }, [fetchSessions]);\n\n  useEffect(() => {\n    fetchSessions();\n  }, [fetchSessions]);\n\n  // Realtime-ish updates: refresh sessions when agent turn finishes\n  useEffect(() => {\n    if (!client) return;\n    const unsub = client.onEvent((frame) => {\n      if (frame.event !== \"agent\") return;\n      const raw = frame.payload as Record<string, unknown>;\n      const stream = raw.stream as string | undefined;\n      const data = raw.data as Record<string, unknown> | undefined;\n\n      if (stream === \"lifecycle\" && (data?.phase === \"end\" || data?.phase === \"start\")) {\n        refreshThrottled();\n      }\n    });\n    return unsub;\n  }, [client, refreshThrottled]);\n\n  // Periodic safety refresh so header metadata does not go stale\n  useEffect(() => {\n    if (state !== \"connected\") return;\n    const id = setInterval(() => {\n      refreshThrottled();\n    }, 15000);\n    return () => clearInterval(id);\n  }, [state, refreshThrottled]);\n\n  return { sessions, loading, refresh: fetchSessions };\n}\n\n// --- Helpers ---\n\n/** Strip OpenClaw inbound metadata from user messages */\nfunction stripInboundMeta(text: string): string {\n  // Remove \"Conversation info (untrusted metadata):\\n```json\\n{...}\\n```\\n\" blocks\n  let cleaned = text.replace(/Conversation info \\(untrusted metadata\\):\\s*```json\\s*\\{[\\s\\S]*?\\}\\s*```\\s*/g, \"\");\n  // Remove \"[Thu 2026-02-19 21:46 GMT+9] \" style timestamps at start\n  cleaned = cleaned.replace(/^\\[[\\w\\s\\-:+]+\\]\\s*/g, \"\");\n  return cleaned.trim();\n}\n\n// --- useChat ---\n\nexport interface DisplayAttachment {\n  fileName: string;\n  mimeType: string;\n  /** data URL for local preview */\n  dataUrl?: string;\n}\n\nexport interface DisplayMessage {\n  id: string;\n  role: \"user\" | \"assistant\" | \"system\";\n  content: string;\n  timestamp: string;\n  toolCalls: ToolCall[];\n  streaming?: boolean;\n  /** Message is queued and not yet sent to the gateway */\n  queued?: boolean;\n  /** Attachments (images, files) */\n  attachments?: DisplayAttachment[];\n}\n\nexport function useChat(sessionKey?: string) {\n  const { client, state } = useGateway();\n  const [messages, setMessages] = useState<DisplayMessage[]>([]);\n  const [streaming, setStreaming] = useState(false);\n  const [loading, setLoading] = useState(false);\n  const streamBuf = useRef<{\n    id: string;\n    content: string;\n    toolCalls: Map<string, ToolCall>;\n  } | null>(null);\n  const sessionKeyRef = useRef(sessionKey);\n\n  // Queue storage key (must be before loadHistory which references it)\n  const queueStorageKey = sessionKey ? `awf:queue:${sessionKey}` : null;\n\n  // Reset state on session change\n  useEffect(() => {\n    if (sessionKeyRef.current !== sessionKey) {\n      sessionKeyRef.current = sessionKey;\n      setMessages([]);\n      setStreaming(false);\n      streamBuf.current = null;\n    }\n  }, [sessionKey]);\n\n  // Load history\n  const loadHistory = useCallback(async () => {\n    if (!client || state !== \"connected\") return;\n    setLoading(true);\n    try {\n      const res = await client.request<{ messages: ChatMessage[] }>(\n        \"chat.history\",\n        { sessionKey, limit: 100 }\n      );\n      const histMsgs: DisplayMessage[] = (res?.messages || [])\n        .filter((m) => m.role === \"user\" || m.role === \"assistant\" || m.role === \"system\")\n        .map((m, i) => {\n          // Extract text and images from content\n          let textContent = '';\n          const imgAttachments: DisplayAttachment[] = [];\n\n          if (typeof m.content === 'string') {\n            textContent = m.content;\n          } else if (Array.isArray(m.content)) {\n            const parts = m.content as Array<Record<string, unknown>>;\n            const hasToolUse = parts.some(p => p.type === 'tool_use');\n            for (const p of parts) {\n              if (p.type === 'text' && typeof p.text === 'string') {\n                // Skip short narration between tool calls (e.g. \"패널 루트에 ref:\")\n                if (hasToolUse && m.role === 'assistant') {\n                  const text = (p.text as string).trim();\n                  // Keep substantial text blocks (>100 chars or multi-line with content)\n                  if (text.length < 100 && !text.includes('\\n')) continue;\n                }\n                textContent += p.text;\n              } else if (p.type === 'image_url' || p.type === 'image') {\n                const url = typeof p.image_url === 'object' && p.image_url\n                  ? (p.image_url as Record<string, string>).url\n                  : typeof p.url === 'string' ? p.url\n                  : typeof p.source === 'object' && p.source\n                    ? `data:${(p.source as Record<string, string>).media_type};base64,${(p.source as Record<string, string>).data}`\n                    : undefined;\n                if (url) {\n                  imgAttachments.push({\n                    fileName: 'image',\n                    mimeType: 'image/png',\n                    dataUrl: url,\n                  });\n                }\n              }\n            }\n          } else {\n            textContent = String(m.content || '');\n          }\n\n          if (m.role === 'user') textContent = stripInboundMeta(textContent);\n\n          return {\n          id: `hist-${i}`,\n          role: (m.role === 'system' || (m.role === 'user' && /\\[System Message\\]|\\[sessionId:|^System:\\s*\\[/.test(textContent)))\n            ? 'system' as const\n            : m.role as \"user\" | \"assistant\",\n          content: textContent,\n          timestamp: m.timestamp || new Date().toISOString(),\n          toolCalls: m.toolCalls || [],\n          attachments: imgAttachments.length > 0 ? imgAttachments : undefined,\n        };});\n      // Restore queued messages from localStorage\n      const savedQueue = queueStorageKey ? localStorage.getItem(queueStorageKey) : null;\n      if (savedQueue) {\n        try {\n          const queue = JSON.parse(savedQueue) as { id: string; text: string }[];\n          queueRef.current = queue;\n          const queuedMsgs: DisplayMessage[] = queue.map((q) => ({\n            id: q.id,\n            role: \"user\" as const,\n            content: q.text,\n            timestamp: new Date().toISOString(),\n            toolCalls: [],\n            queued: true,\n          }));\n          setMessages([...histMsgs, ...queuedMsgs]);\n        } catch {\n          setMessages(histMsgs);\n        }\n      } else {\n        setMessages(histMsgs);\n      }\n    } catch {\n      // silently fail\n    } finally {\n      setLoading(false);\n    }\n  }, [client, state, sessionKey, queueStorageKey]);\n\n  useEffect(() => {\n    loadHistory();\n  }, [loadHistory]);\n\n  // Handle agent events\n  useEffect(() => {\n    if (!client) return;\n\n    // Deduplicate events by frame.seq to prevent double-rendering\n    let lastSeq = -1;\n\n    const unsub = client.onEvent((frame: EventFrame) => {\n      if (frame.event !== \"agent\") return;\n\n      // Deduplicate: gateway sometimes sends the same event twice\n      // Use frame-level seq (not payload.seq)\n      if (frame.seq != null) {\n        if (frame.seq <= lastSeq) return;\n        lastSeq = frame.seq;\n      }\n\n      const raw = frame.payload as Record<string, unknown>;\n\n      // Real Gateway payload: {runId, stream, data:{text,delta}, sessionKey}\n      const stream = raw.stream as string | undefined;\n      const data = raw.data as Record<string, unknown> | undefined;\n      const evSessionKey = raw.sessionKey as string | undefined;\n\n      // Filter events: only process events matching current session\n      if (evSessionKey && evSessionKey !== sessionKeyRef.current) return;\n      if (!evSessionKey && sessionKeyRef.current) return;\n\n      // Map real gateway events to our handler\n      if (stream === \"assistant\" && (typeof data?.delta === \"string\" || typeof data?.text === \"string\")) {\n        // Streamed delta or one-shot text\n        const chunk = (data?.delta as string | undefined) ?? (data?.text as string);\n          setStreaming(true);\n          if (!streamBuf.current) {\n            const id = `stream-${Date.now()}`;\n            streamBuf.current = { id, content: \"\", toolCalls: new Map() };\n          }\n          streamBuf.current.content += chunk;\n          const snap = streamBuf.current;\n          setMessages((prev) => {\n            const existing = prev.findIndex((m) => m.id === snap.id);\n            const msg: DisplayMessage = {\n              id: snap.id,\n              role: \"assistant\",\n              content: snap.content,\n              timestamp: new Date().toISOString(),\n              toolCalls: Array.from(snap.toolCalls.values()),\n              streaming: true,\n            };\n            if (existing >= 0) {\n              const next = [...prev];\n              next[existing] = msg;\n              return next;\n            }\n            return [...prev, msg];\n          });\n      } else if (stream === \"tool-start\" && data) {\n        // tool-call-start\n          const callId = (data.toolCallId || data.callId || \"\") as string;\n          const name = (data.name || data.tool || \"\") as string;\n          const args = data.args as string | undefined;\n          if (!streamBuf.current) {\n            const id = `stream-${Date.now()}`;\n            streamBuf.current = { id, content: \"\", toolCalls: new Map() };\n          }\n          streamBuf.current.toolCalls.set(callId, {\n            callId,\n            name,\n            args,\n            status: \"running\",\n          });\n          const snapTool = streamBuf.current;\n          setMessages((prev) => {\n            const existing = prev.findIndex((m) => m.id === snapTool.id);\n            const msg: DisplayMessage = {\n              id: snapTool.id,\n              role: \"assistant\",\n              content: snapTool.content,\n              timestamp: new Date().toISOString(),\n              toolCalls: Array.from(snapTool.toolCalls.values()),\n              streaming: true,\n            };\n            if (existing >= 0) {\n              const next = [...prev];\n              next[existing] = msg;\n              return next;\n            }\n            return [...prev, msg];\n          });\n      } else if (stream === \"tool-end\" && data) {\n        // tool-call-end\n          const callId = (data.toolCallId || data.callId || \"\") as string;\n          const result = data.result as string | undefined;\n          if (streamBuf.current) {\n            const tc = streamBuf.current.toolCalls.get(callId);\n            if (tc) {\n              tc.status = \"done\";\n              tc.result = result;\n            }\n            const snapEnd = streamBuf.current;\n            setMessages((prev) => {\n              const existing = prev.findIndex((m) => m.id === snapEnd.id);\n              if (existing >= 0) {\n                const next = [...prev];\n                next[existing] = {\n                  ...next[existing],\n                  toolCalls: Array.from(snapEnd.toolCalls.values()),\n                };\n                return next;\n              }\n              return prev;\n            });\n          }\n      } else if (stream === \"lifecycle\" && data?.phase === \"end\") {\n        // lifecycle end = done\n          setStreaming(false);\n          if (streamBuf.current) {\n            const finalId = streamBuf.current.id;\n            const finalContent = streamBuf.current.content;\n            const finalTools = Array.from(streamBuf.current.toolCalls.values());\n            setMessages((prev) =>\n              prev.map((m) =>\n                m.id === finalId\n                  ? { ...m, content: finalContent, toolCalls: finalTools, streaming: false }\n                  : m\n              )\n            );\n            streamBuf.current = null;\n          }\n      } else if (stream === \"done\" || stream === \"end\" || stream === \"finish\") {\n        // done\n          setStreaming(false);\n          if (streamBuf.current) {\n            const finalId = streamBuf.current.id;\n            const finalContent = (data?.text as string) || streamBuf.current.content;\n            const finalTools = Array.from(streamBuf.current.toolCalls.values());\n            setMessages((prev) =>\n              prev.map((m) =>\n                m.id === finalId\n                  ? { ...m, content: finalContent, toolCalls: finalTools, streaming: false }\n                  : m\n              )\n            );\n            streamBuf.current = null;\n          }\n      } else if (stream === \"error\") {\n        // error\n          setStreaming(false);\n          const errMsg = (data?.message || data?.error || \"Unknown error\") as string;\n          if (streamBuf.current) {\n            const errId = streamBuf.current.id;\n            setMessages((prev) =>\n              prev.map((m) =>\n                m.id === errId\n                  ? { ...m, content: m.content + `\\n\\n**Error:** ${errMsg}`, streaming: false }\n                  : m\n              )\n            );\n            streamBuf.current = null;\n          }\n      }\n    });\n\n    return unsub;\n  }, [client, sessionKey]);\n\n  // Message queue for messages sent while streaming — persist to localStorage\n  const queueRef = useRef<{ id: string; text: string }[]>(\n    (() => {\n      if (queueStorageKey && typeof window !== \"undefined\") {\n        try {\n          const saved = localStorage.getItem(queueStorageKey);\n          return saved ? JSON.parse(saved) : [];\n        } catch { return []; }\n      }\n      return [];\n    })()\n  );\n  const processingQueue = useRef(false);\n\n  const persistQueue = useCallback(() => {\n    if (!queueStorageKey) return;\n    if (queueRef.current.length > 0) {\n      localStorage.setItem(queueStorageKey, JSON.stringify(queueRef.current));\n    } else {\n      localStorage.removeItem(queueStorageKey);\n    }\n  }, [queueStorageKey]);\n\n  // Actually send a message to the gateway\n  const doSend = useCallback(\n    async (text: string, msgId: string) => {\n      if (!client || state !== \"connected\") return;\n      // Mark message as no longer queued\n      setMessages((prev) =>\n        prev.map((m) => (m.id === msgId ? { ...m, queued: false } : m))\n      );\n      setStreaming(true);\n      try {\n        await client.request(\"chat.send\", {\n          message: text,\n          idempotencyKey: `awf-${Date.now()}-${Math.random().toString(36).slice(2)}`,\n          sessionKey,\n        });\n      } catch (err) {\n        console.error(\"[AWF] chat.send error:\", String(err));\n        setStreaming(false);\n      }\n    },\n    [client, state, sessionKey]\n  );\n\n  // Process queue: send next message when streaming ends\n  const processQueue = useCallback(async () => {\n    if (processingQueue.current) return;\n    processingQueue.current = true;\n    while (queueRef.current.length > 0) {\n      const next = queueRef.current.shift()!;\n      persistQueue();\n      // Check if message was cancelled (removed from messages)\n      const stillExists = await new Promise<boolean>((resolve) => {\n        setMessages((prev) => {\n          resolve(prev.some((m) => m.id === next.id));\n          return prev;\n        });\n      });\n      if (stillExists) {\n        await doSend(next.text, next.id);\n        // Wait for streaming to finish before sending next\n        await new Promise<void>((resolve) => {\n          const check = () => {\n            // Poll streaming state - resolve when not streaming\n            setTimeout(() => {\n              setStreaming((s) => {\n                if (!s) resolve();\n                else check();\n                return s;\n              });\n            }, 200);\n          };\n          check();\n        });\n      }\n    }\n    processingQueue.current = false;\n  }, [doSend]);\n\n  // Send message (queues if currently streaming)\n  const sendMessage = useCallback(\n    (text: string) => {\n      if (!client || state !== \"connected\" || !text.trim()) return;\n\n      const msgId = `user-${Date.now()}-${Math.random().toString(36).slice(2)}`;\n      const userMsg: DisplayMessage = {\n        id: msgId,\n        role: \"user\",\n        content: text,\n        timestamp: new Date().toISOString(),\n        toolCalls: [],\n        queued: streaming,\n      };\n      setMessages((prev) => [...prev, userMsg]);\n\n      if (streaming) {\n        // Queue for later\n        queueRef.current.push({ id: msgId, text });\n        persistQueue();\n      } else {\n        // Send immediately\n        doSend(text, msgId);\n      }\n    },\n    [client, state, streaming, doSend]\n  );\n\n  // When streaming ends, process queue\n  useEffect(() => {\n    if (!streaming && queueRef.current.length > 0) {\n      processQueue();\n    }\n  }, [streaming, processQueue]);\n\n  // Cancel a queued message\n  const cancelQueued = useCallback((msgId: string) => {\n    queueRef.current = queueRef.current.filter((q) => q.id !== msgId);\n    persistQueue();\n    setMessages((prev) => prev.filter((m) => m.id !== msgId));\n  }, [persistQueue]);\n\n  // Abort\n  const abort = useCallback(async () => {\n    if (!client || state !== \"connected\") return;\n    try {\n      await client.request(\"chat.abort\", { sessionKey });\n    } catch {\n      // silently fail\n    }\n    setStreaming(false);\n  }, [client, state, sessionKey]);\n\n  // Add a user message to the display (for external callers like attachment sends)\n  const addUserMessage = useCallback((text: string, attachments?: DisplayAttachment[]) => {\n    const msgId = `user-${Date.now()}-${Math.random().toString(36).slice(2)}`;\n    const userMsg: DisplayMessage = {\n      id: msgId,\n      role: \"user\",\n      content: text,\n      timestamp: new Date().toISOString(),\n      toolCalls: [],\n      queued: streaming,\n      attachments,\n    };\n    setMessages((prev) => [...prev, userMsg]);\n    if (!streaming) {\n      setStreaming(true);\n    }\n  }, [streaming]);\n\n  return {\n    messages,\n    streaming,\n    loading,\n    sendMessage,\n    addUserMessage,\n    cancelQueued,\n    abort,\n    reload: loadHistory,\n  };\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAsCgB;;AApChB;AASA;;;AAXA;;;AA4BA,MAAM,+BAAiB,IAAA,gVAAa,EAAsB;IACxD,QAAQ;IACR,OAAO;AACT;AAEO,SAAS,gBAAgB,KAAqC;QAArC,EAAE,QAAQ,EAA2B,GAArC;;IAC9B,MAAM,CAAC,QAAQ,UAAU,GAAG,IAAA,2UAAQ,EAAuB;IAC3D,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,2UAAQ,EAAkB;IAEpD,IAAA,4UAAS;qCAAC;YACR,MAAM,MAAM,kEAAuC;YACnD,MAAM,QAAQ,wFAAyC;YACvD,QAAQ,GAAG,CAAC,gCAAgC,KAAK,UAAU,uCAAQ,MAAM;YAEzE,MAAM,IAAI,IAAI,mJAAa,CAAC,KAAK;YACjC,UAAU;YAEV,MAAM,QAAQ,EAAE,aAAa;mDAAC,CAAC;oBAC7B,QAAQ,GAAG,CAAC,wBAAwB;oBACpC,SAAS;gBACX;;YACA,EAAE,OAAO;YAET;6CAAO;oBACL;oBACA,EAAE,UAAU;gBACd;;QACF;oCAAG,EAAE;IAEL,qBACE,+VAAC,eAAe,QAAQ;QAAC,OAAO;YAAE;YAAQ;QAAM;kBAC7C;;;;;;AAGP;GA7BgB;KAAA;AA+BT,SAAS;QAEmB;;IADjC,MAAM,MAAM,IAAA,6UAAU,EAAC;IACvB,OAAO;QAAE,GAAG,GAAG;QAAE,gBAAgB,EAAA,cAAA,IAAI,MAAM,cAAV,kCAAA,YAAY,cAAc,KAAI;IAAG;AACpE;IAHgB;AAOT,SAAS;;IACd,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG;IAC1B,MAAM,CAAC,QAAQ,UAAU,GAAG,IAAA,2UAAQ,EAAU,EAAE;IAChD,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,2UAAQ,EAAC;IAEvC,MAAM,cAAc,IAAA,8UAAW;8CAAC;YAC9B,IAAI,CAAC,UAAU,UAAU,aAAa;YACtC,WAAW;YACX,IAAI;gBACF,MAAM,MAAM,MAAM,OAAO,OAAO,CAAyC;gBACzE,UAAU,CAAA,gBAAA,0BAAA,IAAK,MAAM,KAAI,EAAE;YAC7B,EAAE,UAAM;YACN,gBAAgB;YAClB,SAAU;gBACR,WAAW;YACb;QACF;6CAAG;QAAC;QAAQ;KAAM;IAElB,IAAA,4UAAS;+BAAC;YACR;QACF;8BAAG;QAAC;KAAY;IAEhB,OAAO;QAAE;QAAQ;QAAS,SAAS;IAAY;AACjD;IAvBgB;;QACY;;;AA0BrB,SAAS;;IACd,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG;IAC1B,MAAM,CAAC,UAAU,YAAY,GAAG,IAAA,2UAAQ,EAAY,EAAE;IACtD,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,2UAAQ,EAAC;IACvC,MAAM,mBAAmB,IAAA,yUAAM,EAAC;IAEhC,MAAM,gBAAgB,IAAA,8UAAW;kDAAC;YAChC,IAAI,CAAC,UAAU,UAAU,aAAa;YACtC,WAAW;YACX,IAAI;gBACF,MAAM,MAAM,MAAM,OAAO,OAAO,CAA+C,iBAAiB;oBAAE,OAAO;gBAAI;gBAC7G,oEAAoE;gBACpE,MAAM,SAAS,CAAC,CAAA,gBAAA,0BAAA,IAAK,QAAQ,KAAI,EAAE,EAAE,GAAG;qEAAC,CAAC,IAAM,CAAC;4BAC/C,KAAK,OAAO,EAAE,GAAG,IAAI;4BACrB,SAAS;4BACT,WAAW;4BACX,OAAO,EAAE,KAAK,GAAG,OAAO,EAAE,KAAK,IAAI;4BACnC,aAAa;4BACb,WAAW,OAAO,EAAE,SAAS,KAAK,WAAW,IAAI,KAAK,EAAE,SAAS,EAAE,WAAW,KAAK;4BACnF,cAAc;4BACd,oCAAoC;4BACpC,GAAG,CAAC;wBACN,CAAC;;gBACD,YAAY;gBACZ,iBAAiB,OAAO,GAAG,KAAK,GAAG;YACrC,EAAE,UAAM;YACN,gBAAgB;YAClB,SAAU;gBACR,WAAW;YACb;QACF;iDAAG;QAAC;QAAQ;KAAM;IAElB,MAAM,mBAAmB,IAAA,8UAAW;qDAAC;YACnC,MAAM,MAAM,KAAK,GAAG;YACpB,wDAAwD;YACxD,IAAI,MAAM,iBAAiB,OAAO,GAAG,MAAM;YAC3C;QACF;oDAAG;QAAC;KAAc;IAElB,IAAA,4UAAS;iCAAC;YACR;QACF;gCAAG;QAAC;KAAc;IAElB,kEAAkE;IAClE,IAAA,4UAAS;iCAAC;YACR,IAAI,CAAC,QAAQ;YACb,MAAM,QAAQ,OAAO,OAAO;+CAAC,CAAC;oBAC5B,IAAI,MAAM,KAAK,KAAK,SAAS;oBAC7B,MAAM,MAAM,MAAM,OAAO;oBACzB,MAAM,SAAS,IAAI,MAAM;oBACzB,MAAM,OAAO,IAAI,IAAI;oBAErB,IAAI,WAAW,eAAe,CAAC,CAAA,iBAAA,2BAAA,KAAM,KAAK,MAAK,SAAS,CAAA,iBAAA,2BAAA,KAAM,KAAK,MAAK,OAAO,GAAG;wBAChF;oBACF;gBACF;;YACA,OAAO;QACT;gCAAG;QAAC;QAAQ;KAAiB;IAE7B,+DAA+D;IAC/D,IAAA,4UAAS;iCAAC;YACR,IAAI,UAAU,aAAa;YAC3B,MAAM,KAAK;4CAAY;oBACrB;gBACF;2CAAG;YACH;yCAAO,IAAM,cAAc;;QAC7B;gCAAG;QAAC;QAAO;KAAiB;IAE5B,OAAO;QAAE;QAAU;QAAS,SAAS;IAAc;AACrD;IArEgB;;QACY;;;AAsE5B,kBAAkB;AAElB,uDAAuD,GACvD,SAAS,iBAAiB,IAAY;IACpC,iFAAiF;IACjF,IAAI,UAAU,KAAK,OAAO,CAAC,gFAAgF;IAC3G,mEAAmE;IACnE,UAAU,QAAQ,OAAO,CAAC,wBAAwB;IAClD,OAAO,QAAQ,IAAI;AACrB;AAwBO,SAAS,QAAQ,UAAmB;;IACzC,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG;IAC1B,MAAM,CAAC,UAAU,YAAY,GAAG,IAAA,2UAAQ,EAAmB,EAAE;IAC7D,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,2UAAQ,EAAC;IAC3C,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,2UAAQ,EAAC;IACvC,MAAM,YAAY,IAAA,yUAAM,EAId;IACV,MAAM,gBAAgB,IAAA,yUAAM,EAAC;IAE7B,qEAAqE;IACrE,MAAM,kBAAkB,aAAa,AAAC,aAAuB,OAAX,cAAe;IAEjE,gCAAgC;IAChC,IAAA,4UAAS;6BAAC;YACR,IAAI,cAAc,OAAO,KAAK,YAAY;gBACxC,cAAc,OAAO,GAAG;gBACxB,YAAY,EAAE;gBACd,aAAa;gBACb,UAAU,OAAO,GAAG;YACtB;QACF;4BAAG;QAAC;KAAW;IAEf,eAAe;IACf,MAAM,cAAc,IAAA,8UAAW;4CAAC;YAC9B,IAAI,CAAC,UAAU,UAAU,aAAa;YACtC,WAAW;YACX,IAAI;gBACF,MAAM,MAAM,MAAM,OAAO,OAAO,CAC9B,gBACA;oBAAE;oBAAY,OAAO;gBAAI;gBAE3B,MAAM,WAA6B,CAAC,CAAA,gBAAA,0BAAA,IAAK,QAAQ,KAAI,EAAE,EACpD,MAAM;iEAAC,CAAC,IAAM,EAAE,IAAI,KAAK,UAAU,EAAE,IAAI,KAAK,eAAe,EAAE,IAAI,KAAK;gEACxE,GAAG;iEAAC,CAAC,GAAG;wBACP,uCAAuC;wBACvC,IAAI,cAAc;wBAClB,MAAM,iBAAsC,EAAE;wBAE9C,IAAI,OAAO,EAAE,OAAO,KAAK,UAAU;4BACjC,cAAc,EAAE,OAAO;wBACzB,OAAO,IAAI,MAAM,OAAO,CAAC,EAAE,OAAO,GAAG;4BACnC,MAAM,QAAQ,EAAE,OAAO;4BACvB,MAAM,aAAa,MAAM,IAAI;wFAAC,CAAA,IAAK,EAAE,IAAI,KAAK;;4BAC9C,KAAK,MAAM,KAAK,MAAO;gCACrB,IAAI,EAAE,IAAI,KAAK,UAAU,OAAO,EAAE,IAAI,KAAK,UAAU;oCACnD,+DAA+D;oCAC/D,IAAI,cAAc,EAAE,IAAI,KAAK,aAAa;wCACxC,MAAM,OAAO,AAAC,EAAE,IAAI,CAAY,IAAI;wCACpC,uEAAuE;wCACvE,IAAI,KAAK,MAAM,GAAG,OAAO,CAAC,KAAK,QAAQ,CAAC,OAAO;oCACjD;oCACA,eAAe,EAAE,IAAI;gCACvB,OAAO,IAAI,EAAE,IAAI,KAAK,eAAe,EAAE,IAAI,KAAK,SAAS;oCACvD,MAAM,MAAM,OAAO,EAAE,SAAS,KAAK,YAAY,EAAE,SAAS,GACtD,AAAC,EAAE,SAAS,CAA4B,GAAG,GAC3C,OAAO,EAAE,GAAG,KAAK,WAAW,EAAE,GAAG,GACjC,OAAO,EAAE,MAAM,KAAK,YAAY,EAAE,MAAM,GACtC,AAAC,QAAiE,OAA1D,AAAC,EAAE,MAAM,CAA4B,UAAU,EAAC,YAAoD,OAA1C,AAAC,EAAE,MAAM,CAA4B,IAAI,IAC3G;oCACN,IAAI,KAAK;wCACP,eAAe,IAAI,CAAC;4CAClB,UAAU;4CACV,UAAU;4CACV,SAAS;wCACX;oCACF;gCACF;4BACF;wBACF,OAAO;4BACL,cAAc,OAAO,EAAE,OAAO,IAAI;wBACpC;wBAEA,IAAI,EAAE,IAAI,KAAK,QAAQ,cAAc,iBAAiB;wBAEtD,OAAO;4BACP,IAAI,AAAC,QAAS,OAAF;4BACZ,MAAM,AAAC,EAAE,IAAI,KAAK,YAAa,EAAE,IAAI,KAAK,UAAU,gDAAgD,IAAI,CAAC,eACrG,WACA,EAAE,IAAI;4BACV,SAAS;4BACT,WAAW,EAAE,SAAS,IAAI,IAAI,OAAO,WAAW;4BAChD,WAAW,EAAE,SAAS,IAAI,EAAE;4BAC5B,aAAa,eAAe,MAAM,GAAG,IAAI,iBAAiB;wBAC5D;oBAAE;;gBACJ,4CAA4C;gBAC5C,MAAM,aAAa,kBAAkB,aAAa,OAAO,CAAC,mBAAmB;gBAC7E,IAAI,YAAY;oBACd,IAAI;wBACF,MAAM,QAAQ,KAAK,KAAK,CAAC;wBACzB,SAAS,OAAO,GAAG;wBACnB,MAAM,aAA+B,MAAM,GAAG;2EAAC,CAAC,IAAM,CAAC;oCACrD,IAAI,EAAE,EAAE;oCACR,MAAM;oCACN,SAAS,EAAE,IAAI;oCACf,WAAW,IAAI,OAAO,WAAW;oCACjC,WAAW,EAAE;oCACb,QAAQ;gCACV,CAAC;;wBACD,YAAY;+BAAI;+BAAa;yBAAW;oBAC1C,EAAE,UAAM;wBACN,YAAY;oBACd;gBACF,OAAO;oBACL,YAAY;gBACd;YACF,EAAE,UAAM;YACN,gBAAgB;YAClB,SAAU;gBACR,WAAW;YACb;QACF;2CAAG;QAAC;QAAQ;QAAO;QAAY;KAAgB;IAE/C,IAAA,4UAAS;6BAAC;YACR;QACF;4BAAG;QAAC;KAAY;IAEhB,sBAAsB;IACtB,IAAA,4UAAS;6BAAC;YACR,IAAI,CAAC,QAAQ;YAEb,8DAA8D;YAC9D,IAAI,UAAU,CAAC;YAEf,MAAM,QAAQ,OAAO,OAAO;2CAAC,CAAC;oBAC5B,IAAI,MAAM,KAAK,KAAK,SAAS;oBAE7B,4DAA4D;oBAC5D,wCAAwC;oBACxC,IAAI,MAAM,GAAG,IAAI,MAAM;wBACrB,IAAI,MAAM,GAAG,IAAI,SAAS;wBAC1B,UAAU,MAAM,GAAG;oBACrB;oBAEA,MAAM,MAAM,MAAM,OAAO;oBAEzB,uEAAuE;oBACvE,MAAM,SAAS,IAAI,MAAM;oBACzB,MAAM,OAAO,IAAI,IAAI;oBACrB,MAAM,eAAe,IAAI,UAAU;oBAEnC,8DAA8D;oBAC9D,IAAI,gBAAgB,iBAAiB,cAAc,OAAO,EAAE;oBAC5D,IAAI,CAAC,gBAAgB,cAAc,OAAO,EAAE;oBAE5C,yCAAyC;oBACzC,IAAI,WAAW,eAAe,CAAC,QAAO,iBAAA,2BAAA,KAAM,KAAK,MAAK,YAAY,QAAO,iBAAA,2BAAA,KAAM,IAAI,MAAK,QAAQ,GAAG;4BAEnF;wBADd,kCAAkC;wBAClC,MAAM,QAAQ,CAAA,OAAC,iBAAA,2BAAA,KAAM,KAAK,AAAsB,cAAlC,kBAAA,OAAwC,iBAAA,2BAAA,KAAM,IAAI;wBAC9D,aAAa;wBACb,IAAI,CAAC,UAAU,OAAO,EAAE;4BACtB,MAAM,KAAK,AAAC,UAAoB,OAAX,KAAK,GAAG;4BAC7B,UAAU,OAAO,GAAG;gCAAE;gCAAI,SAAS;gCAAI,WAAW,IAAI;4BAAM;wBAC9D;wBACA,UAAU,OAAO,CAAC,OAAO,IAAI;wBAC7B,MAAM,OAAO,UAAU,OAAO;wBAC9B;uDAAY,CAAC;gCACX,MAAM,WAAW,KAAK,SAAS;wEAAC,CAAC,IAAM,EAAE,EAAE,KAAK,KAAK,EAAE;;gCACvD,MAAM,MAAsB;oCAC1B,IAAI,KAAK,EAAE;oCACX,MAAM;oCACN,SAAS,KAAK,OAAO;oCACrB,WAAW,IAAI,OAAO,WAAW;oCACjC,WAAW,MAAM,IAAI,CAAC,KAAK,SAAS,CAAC,MAAM;oCAC3C,WAAW;gCACb;gCACA,IAAI,YAAY,GAAG;oCACjB,MAAM,OAAO;2CAAI;qCAAK;oCACtB,IAAI,CAAC,SAAS,GAAG;oCACjB,OAAO;gCACT;gCACA,OAAO;uCAAI;oCAAM;iCAAI;4BACvB;;oBACJ,OAAO,IAAI,WAAW,gBAAgB,MAAM;wBAC1C,kBAAkB;wBAChB,MAAM,SAAU,KAAK,UAAU,IAAI,KAAK,MAAM,IAAI;wBAClD,MAAM,OAAQ,KAAK,IAAI,IAAI,KAAK,IAAI,IAAI;wBACxC,MAAM,OAAO,KAAK,IAAI;wBACtB,IAAI,CAAC,UAAU,OAAO,EAAE;4BACtB,MAAM,KAAK,AAAC,UAAoB,OAAX,KAAK,GAAG;4BAC7B,UAAU,OAAO,GAAG;gCAAE;gCAAI,SAAS;gCAAI,WAAW,IAAI;4BAAM;wBAC9D;wBACA,UAAU,OAAO,CAAC,SAAS,CAAC,GAAG,CAAC,QAAQ;4BACtC;4BACA;4BACA;4BACA,QAAQ;wBACV;wBACA,MAAM,WAAW,UAAU,OAAO;wBAClC;uDAAY,CAAC;gCACX,MAAM,WAAW,KAAK,SAAS;wEAAC,CAAC,IAAM,EAAE,EAAE,KAAK,SAAS,EAAE;;gCAC3D,MAAM,MAAsB;oCAC1B,IAAI,SAAS,EAAE;oCACf,MAAM;oCACN,SAAS,SAAS,OAAO;oCACzB,WAAW,IAAI,OAAO,WAAW;oCACjC,WAAW,MAAM,IAAI,CAAC,SAAS,SAAS,CAAC,MAAM;oCAC/C,WAAW;gCACb;gCACA,IAAI,YAAY,GAAG;oCACjB,MAAM,OAAO;2CAAI;qCAAK;oCACtB,IAAI,CAAC,SAAS,GAAG;oCACjB,OAAO;gCACT;gCACA,OAAO;uCAAI;oCAAM;iCAAI;4BACvB;;oBACJ,OAAO,IAAI,WAAW,cAAc,MAAM;wBACxC,gBAAgB;wBACd,MAAM,SAAU,KAAK,UAAU,IAAI,KAAK,MAAM,IAAI;wBAClD,MAAM,SAAS,KAAK,MAAM;wBAC1B,IAAI,UAAU,OAAO,EAAE;4BACrB,MAAM,KAAK,UAAU,OAAO,CAAC,SAAS,CAAC,GAAG,CAAC;4BAC3C,IAAI,IAAI;gCACN,GAAG,MAAM,GAAG;gCACZ,GAAG,MAAM,GAAG;4BACd;4BACA,MAAM,UAAU,UAAU,OAAO;4BACjC;2DAAY,CAAC;oCACX,MAAM,WAAW,KAAK,SAAS;4EAAC,CAAC,IAAM,EAAE,EAAE,KAAK,QAAQ,EAAE;;oCAC1D,IAAI,YAAY,GAAG;wCACjB,MAAM,OAAO;+CAAI;yCAAK;wCACtB,IAAI,CAAC,SAAS,GAAG;4CACf,GAAG,IAAI,CAAC,SAAS;4CACjB,WAAW,MAAM,IAAI,CAAC,QAAQ,SAAS,CAAC,MAAM;wCAChD;wCACA,OAAO;oCACT;oCACA,OAAO;gCACT;;wBACF;oBACJ,OAAO,IAAI,WAAW,eAAe,AAlFkB,CAkFlB,iBAAA,2BAAA,KAAM,KAAK,AAlF4B,MAkFvB,OAAO;wBAC1D,uBAAuB;wBACrB,aAAa;wBACb,IAAI,UAAU,OAAO,EAAE;4BACrB,MAAM,UAAU,UAAU,OAAO,CAAC,EAAE;4BACpC,MAAM,eAAe,UAAU,OAAO,CAAC,OAAO;4BAC9C,MAAM,aAAa,MAAM,IAAI,CAAC,UAAU,OAAO,CAAC,SAAS,CAAC,MAAM;4BAChE;2DAAY,CAAC,OACX,KAAK,GAAG;mEAAC,CAAC,IACR,EAAE,EAAE,KAAK,UACL;gDAAE,GAAG,CAAC;gDAAE,SAAS;gDAAc,WAAW;gDAAY,WAAW;4CAAM,IACvE;;;4BAGR,UAAU,OAAO,GAAG;wBACtB;oBACJ,OAAO,IAAI,WAAW,UAAU,WAAW,SAAS,WAAW,UAAU;wBACvE,OAAO;wBACL,aAAa;wBACb,IAAI,UAAU,OAAO,EAAE;4BACrB,MAAM,UAAU,UAAU,OAAO,CAAC,EAAE;4BACpC,MAAM,eAAe,CAAC,iBAAA,2BAAA,KAAM,IAAI,AAAU,KAAK,UAAU,OAAO,CAAC,OAAO;4BACxE,MAAM,aAAa,MAAM,IAAI,CAAC,UAAU,OAAO,CAAC,SAAS,CAAC,MAAM;4BAChE;2DAAY,CAAC,OACX,KAAK,GAAG;mEAAC,CAAC,IACR,EAAE,EAAE,KAAK,UACL;gDAAE,GAAG,CAAC;gDAAE,SAAS;gDAAc,WAAW;gDAAY,WAAW;4CAAM,IACvE;;;4BAGR,UAAU,OAAO,GAAG;wBACtB;oBACJ,OAAO,IAAI,WAAW,SAAS;wBAC7B,QAAQ;wBACN,aAAa;wBACb,MAAM,SAAU,CAAA,iBAAA,2BAAA,KAAM,OAAO,MAAI,iBAAA,2BAAA,KAAM,KAAK,KAAI;wBAChD,IAAI,UAAU,OAAO,EAAE;4BACrB,MAAM,QAAQ,UAAU,OAAO,CAAC,EAAE;4BAClC;2DAAY,CAAC,OACX,KAAK,GAAG;mEAAC,CAAC,IACR,EAAE,EAAE,KAAK,QACL;gDAAE,GAAG,CAAC;gDAAE,SAAS,EAAE,OAAO,GAAG,AAAC,kBAAwB,OAAP;gDAAU,WAAW;4CAAM,IAC1E;;;4BAGR,UAAU,OAAO,GAAG;wBACtB;oBACJ;gBACF;;YAEA,OAAO;QACT;4BAAG;QAAC;QAAQ;KAAW;IAEvB,4EAA4E;IAC5E,MAAM,WAAW,IAAA,yUAAM,EACrB;oCAAC;YACC,IAAI,mBAAmB,aAAkB,aAAa;gBACpD,IAAI;oBACF,MAAM,QAAQ,aAAa,OAAO,CAAC;oBACnC,OAAO,QAAQ,KAAK,KAAK,CAAC,SAAS,EAAE;gBACvC,EAAE,UAAM;oBAAE,OAAO,EAAE;gBAAE;YACvB;YACA,OAAO,EAAE;QACX;KAAC;IAEH,MAAM,kBAAkB,IAAA,yUAAM,EAAC;IAE/B,MAAM,eAAe,IAAA,8UAAW;6CAAC;YAC/B,IAAI,CAAC,iBAAiB;YACtB,IAAI,SAAS,OAAO,CAAC,MAAM,GAAG,GAAG;gBAC/B,aAAa,OAAO,CAAC,iBAAiB,KAAK,SAAS,CAAC,SAAS,OAAO;YACvE,OAAO;gBACL,aAAa,UAAU,CAAC;YAC1B;QACF;4CAAG;QAAC;KAAgB;IAEpB,yCAAyC;IACzC,MAAM,SAAS,IAAA,8UAAW;uCACxB,OAAO,MAAc;YACnB,IAAI,CAAC,UAAU,UAAU,aAAa;YACtC,mCAAmC;YACnC;+CAAY,CAAC,OACX,KAAK,GAAG;uDAAC,CAAC,IAAO,EAAE,EAAE,KAAK,QAAQ;gCAAE,GAAG,CAAC;gCAAE,QAAQ;4BAAM,IAAI;;;YAE9D,aAAa;YACb,IAAI;gBACF,MAAM,OAAO,OAAO,CAAC,aAAa;oBAChC,SAAS;oBACT,gBAAgB,AAAC,OAAoB,OAAd,KAAK,GAAG,IAAG,KAAuC,OAApC,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,KAAK,CAAC;oBACtE;gBACF;YACF,EAAE,OAAO,KAAK;gBACZ,QAAQ,KAAK,CAAC,0BAA0B,OAAO;gBAC/C,aAAa;YACf;QACF;sCACA;QAAC;QAAQ;QAAO;KAAW;IAG7B,uDAAuD;IACvD,MAAM,eAAe,IAAA,8UAAW;6CAAC;YAC/B,IAAI,gBAAgB,OAAO,EAAE;YAC7B,gBAAgB,OAAO,GAAG;YAC1B,MAAO,SAAS,OAAO,CAAC,MAAM,GAAG,EAAG;gBAClC,MAAM,OAAO,SAAS,OAAO,CAAC,KAAK;gBACnC;gBACA,yDAAyD;gBACzD,MAAM,cAAc,MAAM,IAAI;yDAAiB,CAAC;wBAC9C;iEAAY,CAAC;gCACX,QAAQ,KAAK,IAAI;yEAAC,CAAC,IAAM,EAAE,EAAE,KAAK,KAAK,EAAE;;gCACzC,OAAO;4BACT;;oBACF;;gBACA,IAAI,aAAa;oBACf,MAAM,OAAO,KAAK,IAAI,EAAE,KAAK,EAAE;oBAC/B,mDAAmD;oBACnD,MAAM,IAAI;6DAAc,CAAC;4BACvB,MAAM;2EAAQ;oCACZ,oDAAoD;oCACpD;mFAAW;4CACT;2FAAa,CAAC;oDACZ,IAAI,CAAC,GAAG;yDACH;oDACL,OAAO;gDACT;;wCACF;kFAAG;gCACL;;4BACA;wBACF;;gBACF;YACF;YACA,gBAAgB,OAAO,GAAG;QAC5B;4CAAG;QAAC;KAAO;IAEX,+CAA+C;IAC/C,MAAM,cAAc,IAAA,8UAAW;4CAC7B,CAAC;YACC,IAAI,CAAC,UAAU,UAAU,eAAe,CAAC,KAAK,IAAI,IAAI;YAEtD,MAAM,QAAQ,AAAC,QAAqB,OAAd,KAAK,GAAG,IAAG,KAAuC,OAApC,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,KAAK,CAAC;YACrE,MAAM,UAA0B;gBAC9B,IAAI;gBACJ,MAAM;gBACN,SAAS;gBACT,WAAW,IAAI,OAAO,WAAW;gBACjC,WAAW,EAAE;gBACb,QAAQ;YACV;YACA;oDAAY,CAAC,OAAS;2BAAI;wBAAM;qBAAQ;;YAExC,IAAI,WAAW;gBACb,kBAAkB;gBAClB,SAAS,OAAO,CAAC,IAAI,CAAC;oBAAE,IAAI;oBAAO;gBAAK;gBACxC;YACF,OAAO;gBACL,mBAAmB;gBACnB,OAAO,MAAM;YACf;QACF;2CACA;QAAC;QAAQ;QAAO;QAAW;KAAO;IAGpC,qCAAqC;IACrC,IAAA,4UAAS;6BAAC;YACR,IAAI,CAAC,aAAa,SAAS,OAAO,CAAC,MAAM,GAAG,GAAG;gBAC7C;YACF;QACF;4BAAG;QAAC;QAAW;KAAa;IAE5B,0BAA0B;IAC1B,MAAM,eAAe,IAAA,8UAAW;6CAAC,CAAC;YAChC,SAAS,OAAO,GAAG,SAAS,OAAO,CAAC,MAAM;qDAAC,CAAC,IAAM,EAAE,EAAE,KAAK;;YAC3D;YACA;qDAAY,CAAC,OAAS,KAAK,MAAM;6DAAC,CAAC,IAAM,EAAE,EAAE,KAAK;;;QACpD;4CAAG;QAAC;KAAa;IAEjB,QAAQ;IACR,MAAM,QAAQ,IAAA,8UAAW;sCAAC;YACxB,IAAI,CAAC,UAAU,UAAU,aAAa;YACtC,IAAI;gBACF,MAAM,OAAO,OAAO,CAAC,cAAc;oBAAE;gBAAW;YAClD,EAAE,UAAM;YACN,gBAAgB;YAClB;YACA,aAAa;QACf;qCAAG;QAAC;QAAQ;QAAO;KAAW;IAE9B,iFAAiF;IACjF,MAAM,iBAAiB,IAAA,8UAAW;+CAAC,CAAC,MAAc;YAChD,MAAM,QAAQ,AAAC,QAAqB,OAAd,KAAK,GAAG,IAAG,KAAuC,OAApC,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,KAAK,CAAC;YACrE,MAAM,UAA0B;gBAC9B,IAAI;gBACJ,MAAM;gBACN,SAAS;gBACT,WAAW,IAAI,OAAO,WAAW;gBACjC,WAAW,EAAE;gBACb,QAAQ;gBACR;YACF;YACA;uDAAY,CAAC,OAAS;2BAAI;wBAAM;qBAAQ;;YACxC,IAAI,CAAC,WAAW;gBACd,aAAa;YACf;QACF;8CAAG;QAAC;KAAU;IAEd,OAAO;QACL;QACA;QACA;QACA;QACA;QACA;QACA;QACA,QAAQ;IACV;AACF;IA/bgB;;QACY","debugId":null}},
    {"offset": {"line": 1040, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/BIGNO-FC2T/Projects/intelli-claw/src/lib/utils.ts"],"sourcesContent":["import { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS;IAAG,IAAA,IAAA,OAAA,UAAA,QAAA,AAAG,SAAH,UAAA,OAAA,OAAA,GAAA,OAAA,MAAA;QAAG,OAAH,QAAA,SAAA,CAAA,KAAuB;;IACxC,OAAO,IAAA,uOAAO,EAAC,IAAA,iMAAI,EAAC;AACtB","debugId":null}},
    {"offset": {"line": 1061, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/BIGNO-FC2T/Projects/intelli-claw/src/components/ui/tooltip.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport { Tooltip as TooltipPrimitive } from \"radix-ui\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction TooltipProvider({\n  delayDuration = 0,\n  ...props\n}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {\n  return (\n    <TooltipPrimitive.Provider\n      data-slot=\"tooltip-provider\"\n      delayDuration={delayDuration}\n      {...props}\n    />\n  )\n}\n\nfunction Tooltip({\n  ...props\n}: React.ComponentProps<typeof TooltipPrimitive.Root>) {\n  return <TooltipPrimitive.Root data-slot=\"tooltip\" {...props} />\n}\n\nfunction TooltipTrigger({\n  ...props\n}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {\n  return <TooltipPrimitive.Trigger data-slot=\"tooltip-trigger\" {...props} />\n}\n\nfunction TooltipContent({\n  className,\n  sideOffset = 0,\n  children,\n  ...props\n}: React.ComponentProps<typeof TooltipPrimitive.Content>) {\n  return (\n    <TooltipPrimitive.Portal>\n      <TooltipPrimitive.Content\n        data-slot=\"tooltip-content\"\n        sideOffset={sideOffset}\n        className={cn(\n          \"bg-foreground text-background animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance\",\n          className\n        )}\n        {...props}\n      >\n        {children}\n        <TooltipPrimitive.Arrow className=\"bg-foreground fill-foreground z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]\" />\n      </TooltipPrimitive.Content>\n    </TooltipPrimitive.Portal>\n  )\n}\n\nexport { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }\n"],"names":[],"mappings":";;;;;;;;;;;AAGA;AAEA;AALA;;;;AAOA,SAAS,gBAAgB,KAGgC;QAHhC,EACvB,gBAAgB,CAAC,EACjB,GAAG,OACoD,GAHhC;IAIvB,qBACE,+VAAC,qaAAgB,CAAC,QAAQ;QACxB,aAAU;QACV,eAAe;QACd,GAAG,KAAK;;;;;;AAGf;KAXS;AAaT,SAAS,QAAQ,KAEoC;QAFpC,EACf,GAAG,OACgD,GAFpC;IAGf,qBAAO,+VAAC,qaAAgB,CAAC,IAAI;QAAC,aAAU;QAAW,GAAG,KAAK;;;;;;AAC7D;MAJS;AAMT,SAAS,eAAe,KAEgC;QAFhC,EACtB,GAAG,OACmD,GAFhC;IAGtB,qBAAO,+VAAC,qaAAgB,CAAC,OAAO;QAAC,aAAU;QAAmB,GAAG,KAAK;;;;;;AACxE;MAJS;AAMT,SAAS,eAAe,KAKgC;QALhC,EACtB,SAAS,EACT,aAAa,CAAC,EACd,QAAQ,EACR,GAAG,OACmD,GALhC;IAMtB,qBACE,+VAAC,qaAAgB,CAAC,MAAM;kBACtB,cAAA,+VAAC,qaAAgB,CAAC,OAAO;YACvB,aAAU;YACV,YAAY;YACZ,WAAW,IAAA,4HAAE,EACX,qaACA;YAED,GAAG,KAAK;;gBAER;8BACD,+VAAC,qaAAgB,CAAC,KAAK;oBAAC,WAAU;;;;;;;;;;;;;;;;;AAI1C;MAtBS","debugId":null}}]
}